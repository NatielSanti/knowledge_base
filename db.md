[Заглавная](README.md)

# DB

+ [Шпаргалка по SQL](db.md#Шпаргалка-по-SQL)
+ [Языки структуры БД](db.md#Языки-структуры-БД)
+ [Типы БД](db.md#Типы-БД)
+ [CAP theory](db.md#CAP-theory)
+ [Пессимистическая и оптимистическая блокировка](db.md#Пессимистическая-и-оптимистическая-блокировка)
+ [Типы индексов](db.md#Indexes)
+ [Optimizing queries](db.md#Optimizing-queries)
+ [DB Antipattern Using a bd as message queue](db.md#DB-Antipattern-Using-a-bd-as-message-queue)
+ [Content Delivery Networks](db.md#Content-Delivery-Networks)
+ [NoSQL databases](db.md#NoSQL-databases)
+ [Databases scaling](db.md#Databases-scaling)
+ [Location based DB](db.md#Location-based-DB)

[sql-cheatsheet]:img/db/sql-cheatsheet.jpg
[sql-type]:img/db/sql_type.PNG
[sql-nosql]:img/db/sql-nosql.PNG
[cap]:img/db/cap.PNG
[location-db-1]:img/db/location-db-1.png
[location-db-2]:img/db/location-db-2.png

## Шпаргалка по SQL

![icon][sql-cheatsheet]

[sql basics](documents/sql_basic.pdf)
[sql sheet](documents/sql_sheet.pdf)

[к оглавлению](#DB)

## Типы БД

![icon][sql-nosql]

[к оглавлению](#DB)

## Языки структуры БД

![icon][sql-type]

[к оглавлению](#DB)

## CAP theory

- согласованность данных (англ. consistency) — во всех вычислительных узлах в один момент времени данные 
не противоречат друг другу;
- доступность (англ. availability) — любой запрос к распределённой системе завершается корректным откликом, 
однако без гарантии, что ответы всех узлов системы совпадают;
- устойчивость к разделению (англ. partition tolerance) — расщепление распределённой системы на 
несколько изолированных секций не приводит к некорректности отклика от каждой из секций.

Базы данных могут выполнять только 2 из трёх условий:
- *CA* (`Availability + Consistency – Parition tolerance`), 
когда данные во всех узлах кластера согласованы и доступны, но не устойчивы к разделению.
Это означает, что реплики одной и той же информации, распределенные по разным серверам друг другу, 
не противоречат друг другу и любой запрос к распределённой системе завершается корректным откликом. 
Такие системы возможны при поддержке ACID-требований к транзакциям 
(`Атомарность, Согласованность, Изоляция, Долговечность`) и абсолютной надежности сети. 
На практике таких решений на основе кластерных систем управления базами данных почти не существует. 
Классическим примером CA-системы называют распределённую службу каталогов LDAP, 
а также реляционные базы данных (`PostgreSQL, MySQL, MariaDB, MS SQL Server`).
- *CP-система* (`Consistency + Partition tolerance – Availability`) в каждый момент обеспечивает 
целостность данных и способна работать в условиях распада в ущерб доступности, не выдавая отклик на запрос. 
Устойчивость к разделению требует дублирования изменений во всех узлах системы, 
что реализуется с помощью распределённых пессимистических блокировок для сохранения целостности. 
По сути, CP – это система с несколькими синхронно обновляемыми мастер-базами. 
Она всегда корректна, отрабатывая транзакцию, только в том случае, 
если изменения удалось распространить по всем серверам. 
Она продолжает корректно читать данные даже при отказе одного из узлов кластера. 
Но в этом случае запись будет обрываться или сильно задерживаться, 
пока система не убедится в своей целостности и согласованности (консистентности). 
Из NoSQL-СУБД к CP-системам принято относить 
`Apache HBase, MongoDB, Redis, MemcasheDB, Berkley DB, HyperTable и Google Big Table`.
- *AP-система* (`Availability + Partition tolerance – Consistency`) не гарантирует целостность данных, 
обеспечивая их доступность и устойчивость к разделению, например, как в распределённых веб-кэшах и DNS. 
Считается, что большинство NoSQL-СУБД относятся к этому классу систем, 
обеспечивая лишь некоторой уровень согласованности данных в конечном счете (`eventually consistent`). 
Таким образом, AP-система может быть представлена кластером из нескольких узлов, 
каждый из которых может принимать данные, но не обязуется в тот же момент распространять их на другие сервера. 
Такая система отлично справляется с отказами нескольких узлов, но, когда они снова начинают работать, 
возможна выдача пользователям старых данных. К AP-системам относят `CoucheDB, Cassandra, Riak, Amazon DynamoDB`.

![icon][cap]

[к оглавлению](#DB)

## Пессимистическая и оптимистическая блокировка

### Пессимистическое управление параллелизмом

`FOR UPDATE` - блокирует строки до разблокировки. Создаёт два отдельных запроса.
В хибернейте под высокой нагрузкой два связанных запроса из-за
неатомарности могут быть подвержены грязному чтению.
Система блокировок не допускает, чтобы изменение данных одними пользователями влияло на других пользователей.
После того как действие пользователя приводит к блокировке, до тех пор пока инициатор ее не снимет, 
другие пользователи не могут выполнять действия, которые могут вызвать конфликт с блокировкой. 
Это называется пессимистическим управлением, поскольку в основном применяется в средах с 
большим количеством состязаний данных, где затраты на защиту данных с помощью блокировок меньше затрат 
на откат транзакций в случае конфликтов параллелизма.

### Оптимистическое управление параллелизмом

При оптимистическом управлении параллелизмом пользователи не блокируют данные на период чтения. 
Когда пользователь обновляет данные, система проверяет, вносил ли другой пользователь в них изменение 
после считывания. Если другой пользователь изменял данные, возникает ошибка. Как правило, 
при получении сообщения об ошибке пользователь откатывает транзакцию и начинает ее заново. 
Это называется оптимистическим управлением, поскольку в основном применяется в средах с 
небольшим количеством состязаний данных, где затраты на периодический откат транзакции меньше 
затрат на блокировку данных при считывании.

[к оглавлению](#DB)

## Indexes

Индексы бывают кластеризованными и некластеризованными.
Кластеризованные - пример это основной ключ. Кластеризованные ключи создаются по-умолчанию.
Некластеризованные - искусственные индексы, которые могут создаваться отдельно и хранятся отдельно. 

### Как использовать индексы

- Использовать в больших таблицах 
- Не использовать в часто редактируемых таблицах
- Не использовать для столбцов с большим количеством NULL значений

#### Хеш таблицы

Hash-индексы были предложены Артуром Фуллером, и предполагают хранение не самих значений, 
а их хэшей, благодаря чему уменьшается размер(а, соответственно, и увеличивается скорость их обработки) 
индексов из больших полей. Таким образом, при запросах с использованием HASH-индексов, 
сравниваться будут не искомое со значения поля, а хэш от искомого значения с хэшами полей.
Из-за нелинейнойсти хэш-функций данный индекс нельзя сортировать по значению, 
что приводит к невозможности использования в сравнениях больше/меньше и «is null». 
Кроме того, так как хэши не уникальны, то для совпадающих хэшей применяются методы разрешения коллизий.

#### B-Tree

Семейство B-Tree индексов — это наиболее часто используемый тип индексов, 
организованных как сбалансированное дерево, упорядоченных ключей. 
Они поддерживаются практически всеми СУБД как реляционными, так нереляционными, 
и практически для всех типов данных.

Так как большинство, наверное, их хорошо знает(или могут прочесть о них например, здесь), 
то единственное, что, пожалуй, следует здесь отметить, это то, 
что данный тип индекса оптимален для множества с хорошим распределением значений и 
высокой мощностью(cardinality-количество уникальных значений).

#### Bitmap

Bitmap index – метод битовых индексов заключается в создании отдельных битовых карт 
(последовательность 0 и 1) для каждого возможного значения столбца, 
где каждому биту соответствует строка с индексируемым значением, а его значение равное 1 означает, 
что запись, соответствующая позиции бита содержит индексируемое значение для данного столбца или свойства.

[к оглавлению](#DB)

## Масштабирование SQL и NoSQL
Описанные ниже схемы масштабирования применимы как для реляционных баз данных, 
тах и для NoSQL-хранилищ. Разумеется, что у всех баз данных и хранилищ есть своя специфика, 
поэтому мы рассмотрим только основные направления и в детали реализации вдаваться не будем.

#### Партиционирование (partitioning)
Партиционирование — это разбиение таблиц, содержащих большое количество записей, 
на логические части по неким выбранным администратором критериям. 
Партиционирование таблиц делит весь объем операций по обработке данных на несколько 
независимых и параллельно выполняющихся потоков, что существенно ускоряет работу СУБД. 
Для правильного конфигурирования параметров партиционирования необходимо, 
чтобы в каждом потоке было примерно одинаковое количество записей.

Например, на новостных сайтах имеет смысл партиционировать записи по дате публикации, 
так как свежие новости на несколько порядков более востребованы и чаще требуется работа именно с ними, 
а не со всех архивом за годы существования новостного ресурса.

#### Репликация (replication)
Репликация — это синхронное или асинхронное копирование данных между несколькими серверами. 
Ведущие сервера называют мастерами (master), а ведомые сервера — слэйвами (slave). 
Мастера используются для изменения данных, а слэйвы — для считывания. 
В классической схеме репликации обычно один мастер и несколько слэйвов, 
так как в большей части веб-проектов операций чтения на несколько порядков больше, 
чем операций записи. Однако в более сложной схеме репликации может быть и несколько мастеров.

Например, создание нескольких дополнительных slave-серверов позволяет снять с основного сервера 
нагрузку и повысить общую производительность системы, 
а также можно организовать слэйвы под конкретные ресурсоёмкие задачи и таким образом, 
например, упростить составление серьёзных аналитических отчётов — 
используемый для этих целей slave может быть нагружен на 100%, 
но на работу других пользователей приложения это не повлияет.

#### Шардинг (sharding)
Шардинг — это прием, который позволяет распределять данные между разными физическими серверами. 
Процесс шардинга предполагает разнесения данных между отдельными шардами на основе некого ключа шардинга. 
Связанные одинаковым значением ключа шардинга сущности группируются в набор данных по заданному ключу, 
а этот набор хранится в пределах одного физического шарда. Это существенно облегчает обработку данных.

Например, в системах типа социальных сетей ключом для шардинга может быть ID пользователя, 
таким образом все данные пользователя будут храниться и обрабатываться на одном сервере, 
а не собираться по частям с нескольких.

Проблема:
- кроссшардинг. join данных из разных шардов
- статичное число шардов. но можно разбить шард на несколько мини-шардов, иерархичное шардирование.
- Уязвимость к падению отдельный шардов. Но решается мастер-слейв архитектурой


Партиционирование, репликация и шардинг — три основных подхода к масштабированию баз данных. 
Они позволяют обеспечить повышение быстродействия приложения и повысить устойчивость к высоким нагрузкам.

[к оглавлению](#DB)

## Optimizing queries

12 Query optimization tips for better performance
- Tip 1: Add missing indexes
- Tip 2: Check for unused indexes
```roomsql
SELECT
  *
FROM TestTable
WHERE IntColumn = '1';
```
When executing this query, SQL Server will perform implicit data type conversion, 
i.e. convert int data to varchar and run the comparison only after that. 
In this case, indexes won’t be used. 
How can you avoid this? We recommend using the CAST() 
function that converts a value of any type into a specified datatype. 
Look at the query below.
```roomsql
SELECT
  *
FROM TestTable
WHERE IntColumn = CAST(@char AS INT);
```
```roomsql
SELECT
  *
FROM TestTable
WHERE DATEPART(YEAR, SomeMyDate) = '2021';
```
In this case, implicit data type conversion will take place too, 
and the indexes won’t be used. 
To avoid this, we can optimize the query in the following way:
```roomsql
SELECT
  *
FROM TestTable
WHERE SomeDate >= '20210101'
AND SomeDate < '20220101'
```
- Tip 3: Avoid using multiple OR in the FILTER predicate
```roomsql
SELECT
  *
FROM USER
WHERE Name = @P
OR login = @P;
```
If we split this query into two SELECT 
queries and combine them by using the UNION operator, 
SQL Server will be able to make use of the indexes, and the query will be optimized.
```roomsql
SELECT * FROM USER
WHERE Name = @P
UNION
SELECT * FROM USER
WHERE login = @P;
```
- Tip 4: Use wildcards at the end of a phrase only
  Wildcards serve as a placeholder for words and phrases and can be 
added at the beginning/end of them. To make data retrieval faster and more efficient, 
you can use wildcards in the SELECT statement at the end of a phrase. For example:
```roomsql
SELECT
  p.BusinessEntityID
 ,p.FirstName
 ,p.LastName
 ,p.Title
FROM Person.Person p
WHERE p.FirstName LIKE 'And%';
```
However, you might encounter situations where you regularly need 
to search by the last symbols of a word, number, or phrase—for example, 
by the last digits of a telephone number. 
In this case, we recommend creating a persisted computed column and running the 
REVERSE() function on it for easier back-searching.
```roomsql
CREATE TABLE dbo.Customer (
  id INT IDENTITY PRIMARY KEY
 ,CardNo VARCHAR(128)
 ,ReversedCardNo AS REVERSE(CardNo) PERSISTED
)
GO

CREATE INDEX ByReversedCardNo ON dbo.Customer (ReversedCardNo)
GO
CREATE INDEX ByCardNo ON dbo.Customer (CardNo)
GO

INSERT INTO dbo.Customer (CardNo)
  SELECT
    NEWID()
  FROM master.dbo.spt_values sv

SELECT TOP 100
  *
FROM Customer c

--searching for CardNo that end in 510c
SELECT
  *
FROM dbo.Customer
WHERE CardNo LIKE '%510c'

SELECT
  *
FROM dbo.Customer
WHERE ReversedCardNo LIKE REVERSE('%510c')
```
- Tip 5: Avoid too many JOINs
  
When you add multiple tables to a query and join them, you may overload it.
In addition, a large number of tables to retrieve data from may result 
in an inefficient execution plan. When generating a plan, 
the SQL query optimizer needs to identify how the tables are joined, in which order, 
how and when to apply filters and aggregation.

JOIN elimination is one of the many techniques to achieve efficient query plans. 
You can split a single query into several separate queries which can later be joined, 
and thus remove unnecessary joins, subqueries, tables, etc.
- Tip 6: Avoid using SELECT DISTINCT
  However, this may require the tool to process large volumes of data and as a result, 
make the query run slowly. Generally, it is recommended to avoid using 
SELECT DISTINCT and simply execute the SELECT statement but specify columns.
- Tip 7: Use SELECT fields instead of SELECT *
- Tip 8: Use TOP to sample query results
```roomsql
SELECT TOP 5
  p.BusinessEntityID
 ,p.FirstName
 ,p.LastName
 ,p.Title
FROM Person.Person p
WHERE p.FirstName LIKE 'And%';
```
- Tip 9: Run the query during off-peak hours
- Tip 10: Minimize the usage of any query hint
- Tip 11: Minimize large write operations
- Tip 12: Create joins with INNER JOIN (not WHERE)
```roomsql
SELECT
  d.DepartmentID
 ,d.Name
 ,d.GroupName
FROM HumanResources.Department d
INNER JOIN HumanResources.EmployeeDepartmentHistory edh
  ON d.DepartmentID = edh.DepartmentID
```
The INNER JOIN statement returns all matching rows from joined tables, 
while the WHERE clause filters the resulting rows based on the specified condition. 
Retrieving data from multiple tables based on the WHERE keyword condition 
is called NON-ANSI JOINs while INNER JOIN belongs to ANSI JOINs.

There is no difference for SQL Server how you write the query – 
using ANSI or NON-ANSI joins – it’s just much easier to understand and analyze 
queries written using ANSI joins. You can clearly see where the JOIN conditions 
and the WHERE filters are, whether you missed any JOIN or filter predicates, 
whether you joined the required tables, etc.
```roomsql
SELECT
  d.Name
 ,d.GroupName
 ,d.DepartmentID
FROM HumanResources.Department d
    ,HumanResources.EmployeeDepartmentHistory edh
WHERE d.DepartmentID = edh.DepartmentID
```

[ссылка](https://blog.devart.com/how-to-optimize-sql-query.html)

[к оглавлению](#DB)

## DB Antipattern Using a bd as message queue

Когда несколько сервисов обмениваются сообщениями через базу данных.
Прежде всего нужно спросить важна ли масштабируемость и какова нагрузка системы.

- Интервалы запроса данных. Много операций чтения в базу, лишняя загрузка соединения
- бд обычно оптимизированы либо на чтение, либо на запись. Иначе возникают локи и блокировки
- уже обработанные данные необходимо удалять, либо помечать как завершенные. Это дорогие операции
- Масштабируемость. Если бд не справляется, то нам нужна новая бд, куда будут обращаться новые поставщики, 
а как тогда им взаимодействовать со старыми читателями?

+ Если система маленькая, то бд эффективнее
+ Количество операций записи не так велико
+ бд нужна почти всегда, а поднятие кластера очередей даёт нагрузку на сервера

[к оглавлению](#DB)

## Content Delivery Networks

Требования:
- лучше кешировать страницы, если они оказываются статическими
- локализация данных на основе данных клиента (разрешение, язык, сами подборки)
- загрузка должна быть быстрой

Решение:
- Распределенный кеш, потому что внешний кеш в данном случае будет являться бутылочным горлышком. 
Кеш может шардироваться на основе локации. Но тогда все запросы всё равно будут лететь через весь мир в единый дата-центр
- Альтернатива. Кеш дата-центры по всему миру, чтобы пользователи получали данные быстрее.

Преимущества CDN
- Дата-центры близко к пользователям и они могут быстро получать информацию
- Локальные данные могут отличаться друг от друга (статья в Индии и Германии может быть разной)
- Возможность создать UI для загрузки контента в кеши

Примеры
- CloudFront от Amazon с хранилищем S3

[к оглавлению](#DB)

## NoSQL databases

### Особенности

- Данные хранятся в виде BLOB json
- Не использую NoSQL бд Youtube, Stackoverflow, Instagram

### Плюсы и минусы

- +Вся информация сохраняется разом одним BLOB и не дробится по частям
- +Нет обязательной структуры, схемы данных
- +Горизонтальное масштабирование заложено изначально
- +Упрощённая агрегация данных
- -Усложнённые операции UPDATE. Данные могут быть неконсистентны. Не гарантирован ACID. 
Поэтому финансовые системы не используют NoSQL
- -Усложнённый поиск. Запросы с WHERE будут работать гораздо медленнее
- -Сложно организовать реляционность
- -Join сложно организовать

### Пример

Cassandra - может масштабировать горизонтально по ключу. 
При помощи функции консистентного хеша можно записать новую запись в определенную ноду кластера Кассандры.
- Если хеш функция плохая, то есть вероятность неправильного распределения нагрузки между нодами
- Есть опция сделать второй уровень деления, когда нода кластера, это отдельынй подкластер бд
- Данные по одному хешу должны хранитсья в разных нодах
- Необходимые фичи - Load balancing/ redundancy(одни данные хранятся на разных нодах) 
и реплики обеспечиваются кластером кассандры
- Distributed Consensus (Quorum).Предположим что Replication Factor == 3, 
то есть новые данные хранятся сразу в трёх нодах, то истинной информация считается, 
если две их трёх нод содержат какую-то информацию. Это нужно на случай потери консистентности данных.
- Кассандра хранит данные в памяти в форме лог файла. 
Периодически она делает дамп и сохраняет эти данные в файловую систему в SST (Sorted String Table)
- SST иммутабельные. В памяти новые данные записываются и обновляюстя по ключу, 
а уже сохранённые SST не меняются, но тогда получается, что у нас множество записей с одним ключом
- Compaction (уплотнение). Периодически SST складываются в одну, с удалением неактуальных данных. Пометкой о устарении.

[к оглавлению](#DB)

## Databases scaling

- Обычно БД используют `B+tree` для поиска. Это небинарное дерево с хорошей скоростью поиска и записи O(log(n))
- Чтобы организовать быструю запись нужно использовать `linked list`, 
но время чтения и поиска будет больше. Запись O(1), чтение O(n)
- В таком случае лучшее решение linked List + sorted array. Запись О(1), чтение О(log(n))
  - Запись новых данных происходит отсортированные батчами, но новые данные не складываются со старыми, 
  а хранятся отдельно, чтобы не пересортировывать всю бд при изменении данных. Тогда внутри чанков поиск будет быстрый, 
  но их же много, поэтому скорость поиска будет N/количество чанков * lon(n)
  - Чтоюбы это разрешить чанки всё же сливаются, но не всегда, а лишь когда достигается критическое значение
  - Чтобы ускорить поиск можно применить `bloom filter` (Например, когда мы добавляем слово "КОШКА" в бд, 
  в её заголовке чанка мы отмечаем букву "К" - "у нас есть слова на букву К". Когда мы будем искать "КОРОВА" 
  этот фильтр заставит нас искать в этом чанке, но зато мы не будем искать "КОРОВА" в чанках где буква К не отмечена)

[к оглавлению](#DB)

## Location based DB

Используются например в google maps.

### Требования:

1) система координат
   - универсальный механизм назначения адреса (zip, pin, индекс)
   - возможность делить регионы на более мелкие
2) эффективная система замера расстояния

### Как?

1) Система координат (широта и долгота) 
   - + хорошо отвечает первому требованию
   - - но слабо отвечает второму, потому что для замера расстояния нужно каждый раз вычислять расстояния 
   по точкам координат.
   - - в бд такие значения будут храниться в 32-бит или 64 битном числе, но это не точные числа, 
   а часто лишь приблизительные
   
2) Разделение мира на 4 региона, потом эти регионы делим еще на 4 региона и тд
   - + мы делим регионы только когда это нужно (например огромная закрытая территория не нужна для сервиса доставки еды, 
   так как мы будем доставлять только до главного входа) 
   - + расстояние можно определять внутри региона, при этом отбрасывая остальные более крупные регионы, 
   то есть вычисления будут быстрее и дешевле
   - - карта будет построена по образу дерева с 4 листьями, но иногда нам нужно будет делить слишком много. 
   Например, густонаселенный участок будет требовать сильного деления, по сравнению с малонаселенным участком
   
3) Вся территория преобразуется не в 2 измерения, а в одно (`фракталы`) `Z` (не подходит из-за наличия длинной линии), 
`hilbert-shape` (наш выбор), `alpha-shape`(не подходит)
![icon][location-db-1]

- + используется только одно измерение, что упрощает вычисления
- + у hilbert-shape потомки разворачиваются, чтобы сохранить
![icon][location-db-2]

- - сложно выбрать `trashhold` отступ, для определения ближайшей точки, но вероятность такого относительно мала

[к оглавлению](#DB)

[Заглавная](README.md)
