[Заглавная](README.md)

# Java Version Features
+ [Java 8](java-version-features.md#Java-8)
+ [Java 9](java-version-features.md#Java-9)
+ [Java 10](java-version-features.md#Java-10)
+ [Java 11](java-version-features.md#Java-11)
+ [Java 12](java-version-features.md#Java-12)
+ [Java 13](java-version-features.md#Java-13)

[к оглавлению](#Java-Version-Features)

##Java 8

###Java Stream Api
[Java Stream Api](java-stream.md)

###Functional Interface
Что это? Функциональный интерфейс — это интерфейс, содержащий один нереализованный (абстрактный) метод.
Но как всегда у нас есть некоторые оговорки: default и static методы не попадают под эти требования. 
Поэтому может быть несколько таких методов + один абстрактный, и интерфейс будет функциональным. 
Также он может содержать методы класса Object, которые не влияют на определение интерфейса как функционального.

Добавлю пару слов о default и static методах:
Методы с модификатором default позволяют добавлять новые методы в интерфейсы, не нарушая их существующую реализацию.
```java
public interface Something {
  default void someMethod() {
      System.out.println("Some text......");
  }
}
```
Да-да, мы добавляем реализованный метод в интерфейс, и при имплементации данного метода его можно не переопределять, 
а использовать как унаследованный. Но если класс реализует два интерфейса с данным методом, 
у нас будет ошибка компиляции, а если реализует интерфейсы и наследует класс с определенным одинаковым методом, 
метод класса родителя будет перекрывать методы интерфейса и эксепшен не вылезет.

Методы static в интерфейсе работают так же, как и static методы в классе. 
Не забываем: наследовать static методы нельзя, как нельзя вызывать и static метод из класса-наследника.

```boolean someMethod(T t);```
Predicate — принимает аргументом некоторое значение T, возвращает boolean.

```void someMethod(T t);```
Consumer — принимает аргумент типа Т, ничего не возвращает (void).

```T someMethod();```
Supplier — ничего не принимает на вход, но возвращает некоторое значение T.

```R someMethod(T t);```
Function — принимает на вход параметр типа Т, возвращает значение типа R.

```T someMethod(T t);```
UnaryOperator — принимает аргумент Т и возвращает значение типа Т.

###Lambda
Это блок кода, который можно передать в различные места, 
исходя из этого он может быть выполнен позже столько раз, сколько потребуется. Звучит довольно запутанно, не так ли?

Проще говоря, с помощью лямбд, можно реализовывать метод функционального интерфейса 
(такая себе реализация анонимного класса):
```java
Runnable runnable = () -> { System.out.println("I'm running !");};
new Thread(runnable).start();
```

###foreach
В Java 8 появился новый foreach, который работает с потоком данных как и стрим.
```java
List<Integer> someList = Arrays.asList(1, 3, 5, 7, 9);
someList.forEach(x -> System.out.println(x));
```

###Method reference
Ссылочные методы — это новый полезный синтаксис, созданный чтобы ссылаться на существующие методы или конструкторы 
Java-классов или объектов через ::

Ссылки на методы бывают четырех видов:
- Ссылка на конструктор:
```SomeObject obj = SomeObject::new```

- Ссылка на статический метод:
```SomeObject::someStaticMethod```

- Ссылка на нестатический метод объекта определенного типа:
```SomeObject::someMethod```

- Ссылка на обычный(нестатический) метод конкретного объекта
```obj::someMethod```

Часто ссылки на методы используются в стримах вместо лямбд (ссылочные методы быстрее лямбд, но уступают в читаемости).

```java
someList.stream().map(String::toUpperCase).forEach(System.out::println);
```

###API Time
- LocalDate — это конкретная дата, как пример — 2010-01-09;
- LocalTime — время, учитывающее часовой пояс — 19:45:55 (аналог LocalDate);
- LocalDateTime — комбо LocalDate + LocalTime — 2020-01-04 15:37:47;
- ZoneId — представляет часовые пояса;
- Clock — с помощью этого типа можно достучаться до текущего времени и дате.

###Optional
Это новый класс в пакете java.util, обёртка (контейнер) для значений, фишкой которой является то, 
что она также может безопасно содержать null.
```java
Optional<String> someOptional = Optional.of("Something");
Optional<String> someOptional = Optional.ofNullable("Something");
Optional<String> someOptional = Optional.empty();
someOptional.isPresent();
someOptional.ifPresent(System.out::println);
System.out.println(someOptional.orElse("Some default content"));
```

[к оглавлению](#Java-Version-Features)

##Java 9

###JShell (REPL — read-eval-print loop)

###private методы в интерфейсах
Начиная с 9 версии Java, у нас появилась возможность использовать private методы в интерфейсах 
(default и static методы, так как другие мы попросту не можем переопределить из-за недостаточного доступа).

###Модульность
Модуль — это группа взаимосвязанных пакетов и ресурсов вместе с новым файлом дескриптора модуля. 
Данный подход используется, чтобы ослабить связанность кода. Ослабление связи — 
ключевой фактор для удобства поддержки и расширяемости кода.

Модульность реализуется на разных уровнях:
- Языка программирования.
- Виртуальной машины.
- Стандартного java API.
- JDK 9 поставляется с 92 модулями: мы можем юзать их или создать свои.

###Immutable Collection
В Java 9 стало возможным создание и заполнение коллекции одной строкой, при этом делая её immutable 
(ранее для создания immutable коллекции нам нужно было создать коллекцию, заполнить её данными, и вызов метода, 
например — Collections.unmodifiableList).

```java
List someList = List.of("first","second","third");
```

###Другие нововведения:
- расширен Optional (добавлены новые методы);
- появились интерфейсы ProcessHandle и ProcessHandle для управления действиями операционной системы;
- G1 — дефолтный сборщик мусора;
- HTTP клиент с поддержкой как HTTP/2 протокола и WebSocket;
- расширен Stream;
- добавлен фреймворк Reactive Streams API (для реактивного программирования);

[к оглавлению](#Java-Version-Features)

##Java 10

###var
Теперь мы можем не предоставлять тип данных. Мы помечаем сообщение как var, 
и компилятор определяет тип сообщения по типу инициализатора, присутствующего справа. 
Данная фича доступна только для локальных переменных с инициализатором: ее нельзя использовать для аргументов методов, 
типов возвращаемых данных и т.д., так как там нет инициализатора для возможности определения типа.
```java
var message = "Some message…..";
System.out.println(message);
```
var не является ключевым словом: по сути это зарезервированное имя типа, как и int.

Пользова от var большая: объявления типов забирают на себя много внимания, не принося никакой пользы, 
а эта фича сэкономит время. Но в тоже время, если переменная получается из длинной цепочки методов, 

код становится менее читаемым, так как сходу неясно, что за объект там лежит.

###JIT-compiler (GraalVM)
Без лишних предисловий напомню: при запуске команды javac, приложение Java компилируется из Java-кода в байткод JVM, 
который является бинарным представлением приложения. Но обычный процессор компьютера не может просто так выполнить 
байткод JVM.

Для работы вашей программы JVM нужен ещё один компилятор уже для этого байткода, который преобразуется в машинный код, 
который процессор уже в состоянии использовать.

В сравнении с  javac, этот компилятор намного более сложный, но и в результате выдает более 
высококачественный машинный код.

На данный момент OpenJDK содержит виртуальную машину HotSpot, у которой, в свою очередь, 
есть два основных JIT-компилятора.

**Первый** — C1(клиентский компилятор), создан для более высокоскоростной работы, но при этом страдает оптимизация кода.

**Второй** — C2 (серверный компилятор). Страдает уже скорость выполнения, но при этом код более оптимизирован.

Когда используется какой? С1 отлично подходит для настольных приложений, где нежелательны долгие паузы JIT-компилятора,
 а С2 — для долгоработающих серверных программ, в которых вполне сносно потратить больше времени на компиляцию.

**Многоуровневая компиляция** — это когда сперва компиляция проходит с помощью С1, 
а результат проходит через С2 (используется для большей оптимизации).

**GraalVM** — это  проект, созданный для полной замены HotSpot. 
Мы можем рассматривать Graal как несколько связанных проектов: новый JIT-компилятор для HotSpot и 
новую виртуальную машину polyglot.

Особенность данного JIT-компилятора заключается в том, что он написан на Java. Преимущество Graal компилятора — 
безопасность, то есть не сбои, а исключения, а не утечки памяти. Также мы будем иметь хорошую поддержку IDE, 
и мы сможем юзать отладчики, профилировщики или другие удобные инструменты. Помимо этого, 
компилятор вполне себе может быть независимым от HotSpot, и он сможет создавать более быструю JIT-скомпилированную 
версию самого себя.

###Паралельный G1
Сборщик мусора G1 конечно крут, спору нет, но есть и слабое место: он выполняет однопоточный полный цикл GC. 
В то время, когда вам нужна вся мощь  оборудования, которое вы можете собрать для поиска неиспользуемых объектов, 
мы ограничиваемся одним потоком. 

В Java 10 это исправили.Теперь GC теперь работает со всеми ресурсами, которые мы к нему добавляем (то есть, 
становится многопоточным).

Для этого разработчики языка улучшили изоляцию основных исходников от GC , создав для GC хороший чистый интерфейс.  
Разработчикам данной милоты —  OpenJDK, пришлось конкретно разгрести свалку в коде, 
чтобы не только максимально упростить создание новых GC, но и дать возможность быстро отключать ненужные GC из сборки.
 Один из основных критериев успеха — отсутствие просадки по скорости работы после всех этих улучшений.

###Другие нововведения

- Вводится чистый интерфейс сборщика мусора (Garbage-Collector Interface). 
Благодаря этому улучшается изоляция исходного кода от разных сборщиков мусора, 
давая возможность интегрировать альтернативные сборщики быстро и «безболезненно»;
- Объединение исходников JDK в один репозиторий;
- Коллекции получили новый метод — copyOf (Collection), который возвращает неизменную копию это коллекции;
- Optional (и его разновидности) получил новый метод .orElseThrow();
- Отныне JVM знают о том, что они запускаются в контейнере Docker, и будут извлекать специфичную для контейнера 
конфигурацию, а не запрашивать саму операционную систему.

[к оглавлению](#Java-Version-Features)

##Java 11

###var (в лямбде)
Отныне и во веки веков мы можем указать типы лямбда-параметров или пропустить их при написании лямбда-выражения (
неявно типизированных лямбда-выражений):
```java
Function<String, String> append = (var string) -> string + " Text";
String appendedString = append.apply("Some");
System.out.println(appendedString);
```
Также можно добавлять аннотации к лямбда-параметрам без необходимости писать полное имя типа переменной:
```java
Function<String, String> append = (@NonNull var string) -> string + " Text";
```

###Z (ZGC)
ZGC — это новый сборщик мусора, который не работает. Он выделяет новую память, но никогда не перезапускает ее. 
ZGC обещает управлять большими объемами памяти с высокой пропускной способностью и коротким временем паузы (
ZGC доступен только на 64-битных платформах).

Эталонная окраска — ZGC использует 64-битные указатели с техникой, называемой окрашиванием указателей. 
Цветные указатели хранят дополнительную информацию об объектах в куче. Когда память становится фрагментированной, 
это помогает избежать снижения производительности, когда GC необходимо найти место для нового распределения.

Сборка мусора с помощью ZGC состоит из таких этапов:
- остановки мира: мы ищем отправные точки для достижения объектов в куче (
например, локальных переменных или статических полей);
- пересечение граф объектов, начиная с корневых ссылок. Мы отмечаем каждый объект, который достигаем (
ZGC ходит по графу объектов и исследует цветные указатели, отмечая доступные объекты);
- обработки некоторых крайних случаев, например, слабых ссылок;
- перемещение живых объектов, освобождая большие участки кучи, чтобы ускорить распределение.
- когда начинается фаза перемещения, ZGC разделяет кучу на страницы и работает по одной странице за раз;
- ZGC заканчивает движение любых корней, и происходит остальная часть перемещения.

###Epsilon GC
Эпсилон — это сборщик мусора, который обрабатывает выделение памяти, но не реализует какой-либо реальный механизм 
ее восстановления памяти. Как только доступная куча Java будет исчерпана, JVM закроется. То есть, 
если в бесконечном массиве запустить создание объекта без привязки к ссылке с данным сборщиком мусора, 
приложение упадёт с OutOfMemoryError (а если с любым другим нет, так как он будет подчищать объекты без ссылок).
- Тестирование производительности.
- Тестирование давления памяти.
- Тестирование интерфейса VM.
- Чрезвычайно недолгая работа.
- Улучшения латентности последней капли.
- Улучшения пропускной способности последней капли.

###Другие нововведения:
1) ByteArrayOutputStream получил метод void writeBytes(byte []), записывающий все байты из аргумента в OutputStream.
2) FileReader и FileWriter получили новые конструкторы, позволяющие указывать Charset.
3) Path отхватил два новых метода, of(String, String []) возвращает Path из строкового аргумента пути или 
последовательности строк, которые при объединении образуют строку пути и of(URI): возвращает Path из URI.
4) Pattern — получил метод asMatchPredicate(), который проверяет, соответствует ли заданная строка ввода, 
заданному шаблону (позволяет ли создать предикат по регулярному выражению, чтобы можно было, например, 
фильтровать данные в stream).
5) String отхватил много полезных методов, таких как:
    - String strip(): вернёт нам строку, которая является этой строкой, при этом удаляются все пробелы в начале 
    и в конце строки (аналог trim(), но по-другому определяет пробелы);
    - String stripLeading(): вернёт нам строку, которая является этой строкой, при этом удаляются все пробелы 
    в начале строки;
    - String stripTrailing(): вернёт нам строку, которая является этой строкой, при этом удаляются все пробелы 
    в конце строки;
    - Stream lines(): вернёт нам Stream из String, извлеченных из этой строки, поделенных разделителями строк;
    - String repeat(int): вернёт нам строку, которая представляет собой конкатенацию этой строки, повторяющееся 
    количество раз.
    - boolean isBlank(): вернёт нам true, если строка пуста или содержит только пробелы, иначе false.
6) Thread — были удалены методы destroy() и stop(Throwable).
7) Files получил ряд новых методов:
    - String readString(Path): читает все данные из файла в строку, при этом декодируя из байт в символы с 
    использованием кодировки UTF-8;
    - String readString(Path, Charset): так же, как и в методе выше, с разницей в том, что декодирование из байт 
    в символы происходит с использованием указанной Charset;
    - Path writeString (Path, CharSequence, OpenOption []): записывает последовательность символов в файл. 
    Символы кодируются в байты, используя кодировку UTF-8;
    - Path writeString(Path, CharSequence,Charset, OpenOption []): такой же метод, что и выше, только символы 
    кодируются в байты, используя кодировку, указанную в Charset.
    
[к оглавлению](#Java-Version-Features)

##Java 12
###Update G1
Для G1 были внесены такие улучшения:
1) **Возврат неиспользуемой выделенной памяти**
В Java heap memory есть такое понятие как неиспользуемая память (или по-другому — неактивная). 
В Java 12 решили пофиксить эту проблему, теперь:
    - G1 возвращает память из кучи в полном GC или во время параллельного цикла; 
    G1 старается предотвратить полный GC и запускает параллельный цикл, исходя из распределения кучи. 
    Придется принуждать G1 к возвращению памяти из кучи.
Данное улучшение фокусируется на быстродействии за счет автоматического возврата памяти из кучи в ОС, 
когда G1 не используется.
2) **Прерывание смешанных коллекций, когда время паузы превышено**
G1 использует механизм анализа для выбора объема работы, необходимого для сбора мусора. 
Он собирает живые объекты без остановки после определения набора и запуска очистки. Это приводит к тому, 
что сборщик мусора превышает целевое значение времени паузы. Собственно, такую проблему и решает улучшение, 
так как если время выполнения следующего шага выходит за рамки разумного, этот шаг можно прервать.

###Microbenchmark
В Java 12 ввели тесты микробенчмаркинга, чтобы производительность JVM легко тестировалась с помощью уже 
существующих тестов. Это было бы очень полезно для всех, кто хочет работать над самой JVM. 
Добавляемые тесты создаются с использованием Java Microbenchmark Harness (JMH). 
Эти тесты позволяют проводить непрерывное тестирование производительности на JVM. 
JEP 230 предлагает ввести около 100 тестов, причем новые тесты вводятся по мере выпуска новых версий Java.

###Shenandoah
Это алгоритм сборки мусора (GC), цель которого — гарантировать низкое время отклика (нижний предел — 10-500 мс). 
Это уменьшает время паузы GC при выполнении работы по очищению одновременно с работающими потоками Java.

В Shenandoah время паузы не зависит от размера кучи. Это означает, что время паузы будет одинаковым независимо 
от размера вашей кучи. Это **экспериментальная функция**, которая не включена в стандартную (Oracle) сборку OpenJDK.

###Improve Switch
В Java 12 улучшены выражения Switch для сопоставления с образцом. Был введен, новый синтаксис L →.

Вот список ключевых моментов нового switch:
- Новый синтаксис устраняет необходимость в операторе break для предотвращения ошибок.
- Выражения переключателя больше не проваливаются.
- Кроме того, мы можем определить несколько констант в одной метке.
- default регистр теперь обязателен в выражениях переключателей.
- break используется в выражениях Switch для возврата значений из самого регистра (
по сути switch может возвращать значения).

```java
var result = switch (someDay) {
  case "M", "W", "F" -> "MWF";
  case "T", "TH", "S" -> "TTS";
  default -> {
      if(someDay.isEmpty())
            break "Please insert a valid day.";
      else
            break "Looks like a Sunday.";
  }
};
```

###Другие нововведения:
1) **String**
```transform(Function f)``` — применяет предоставленную функцию к строке. Результат может не быть строкой.
```indent(int x)``` — добавляет x пробелов в строку. Если параметр отрицателен, то это количество начальных 
пробелов будет удалено(если это возможно).
2) **Files** — отхватил такой метод как ```mismatch()```, который, в свою очередь, 
находит и возвращает позицию первого несовпадающего байта в содержимом двух файлов или -1L, если нет несоответствия.
3) **Появился новый класс — CompactNumberFormat**, для форматирования десятичного числа в компактной форме. 
Пример такой компактной формы — 1M вместо 1000000. Таким образом, требуется всего лишь два два вместо девяти символов.
4) Существует также новый **enum**, **NumberFormatStyle**, у которого есть два значения — LONG и SHORT.
5) **InputStream** получил метод — ```skipNBytes(long n)```: пропустить n-ое количество байтов из входного потока.

[к оглавлению](#Java-Version-Features)

##Java 13
###Text block
```java
String TEXT_BLOCK_JSON = """
{
    "name" : "someName",
    "site" : "https://www.someSite.com/"
}
""";
```

###Improve Switch
В 12 вы определяете возвращаемые значения с помощью break. В 13 возвращаемое значение заменили на  yield. 
Теперь выражение со switch, которое было у нас в разделе Java 12, можно переписать как:
```java
var result = switch (someDay) {
  case "M", "W", "F" -> "MWF";
  case "T", "TH", "S" -> "TTS";
  default -> {
      if(someDay.isEmpty())
          yield "Please insert a valid day.";
      else
          yield "Looks like a Sunday.";
  }
};
```

###Dynamic CDS Archives
CDS — Class-Data Sharing. Позволяет упаковывать набор часто используемых классов в архив, 
который позже может быть загружен несколькими экземплярами JVM. 

Зачем нам это? Дело в том, что в процессе загрузки классов JVM делает довольно много ресурсозатратных действий, 
таких как чтение классов, сохранение их во внутренних структурах, проверка правильности прочитанных классов, 
поиск и загрузка зависимых классов и т. д., и лишь после всего этого классы готовы к работе. Понятное дело, 
попусту тратится большое количество ресурсов, ведь экземпляры JVM часто могут загружать одни и те же классы. 
Например String, LinckedList, Integer. Ну или же классы одного и того же приложения, а все это — ресурсы.

Если бы мы выполнили все необходимые действия лишь один раз и после поместили переработанные классы в архив, 
который может быть подгружен в память нескольких JVM, это могло бы существенно сэкономить место в памяти и 
сократить время запуска приложения. Собственно, CDS дает возможность создать именно такой архив.

Java 9 позволяла добавлять в архив только системные классы. Java 10 — включать в архив классы приложения. 

Создание такого архива состоит из:
- создания списка классов, загружаемых приложением;
- создания так необходимого нам архива с найденными классами.
Нововведение в Java 13 улучшает CDS так, чтобы он мог создавать архив по завершении приложения. Это означает, 
что два шага, приведенные выше, теперь будут объединены в один.

И ещё один важный момент: только классы, которые были загружены во время работы приложения, будут добавлены в архив. 
Другими словами словами, те классы, которые все же содержатся в application.jar, 
но по каким-то причинам на были загружены, не добавятся в архив.

###Update Socket API
API Socket (java.net.Socket и java.net.ServerSocket) — по сути неотъемлемая часть Java с момента ее появления, 
но при этом сокеты ни разу не апдейтили за последний двадцаток лет.

Написанные на C и Java, они были очень и очень громоздкими и сложными в обслуживании. 
Но Java 13 решила внести свои коррективы в это всё дело и  заменила базовую реализацию.

Теперь вместо PlainSocketImpl интерфейс провайдера заменяется на NioSocketImpl. 
Эта новая кодированная реализация основана на той же внутренней инфраструктуре, что и java.nio. 
По сути класс использует механизм буферного кэша и блокировки java.util.concurrent (которые являются сегментными), 
а не синхронизированные методы. Он больше не требует нативного кода, тем самым упрощая портирование на разные платформы.

Всё же, у нас есть способ вернуться к использованию PlainSocketImpl, но отныне по дефолту используется NioSocketImpl. 

###Memory Return for ZGC
Как мы помним, Z сборщик мусора ввели в Java 11 как механизм сборки мусора с малой задержкой, 
чтобы GC пауза никогда не превышала 10 мс. Но при этом, в отличие от остальных виртуальных GC HotSpot, 
таких как Shenandoah и G1, он мог возвращать неиспользованную динамическую память в ОС. 
Данная модификация добавляет эту возможность J в ZGC.
Соответственно, мы получаем уменьшенный объем памяти вместе с улучшением производительности, 
и ZGC теперь возвращает не зафиксированную память операционной системе по умолчанию, 
пока не будет достигнут указанный минимальный размер кучи.
И ещё: у ZGC теперь есть максимальный поддерживаемый размер кучи 16 ТБ. Раньше 4ТБ было пределом.

###Другие нововведения:
- ```javax.security``` — добавлено свойство ```jdk.sasl.disabledMechanisms``` для отключения механизмов SASL.
- ```java.nio``` — добавлен метод ```FileSystems.newFileSystem (Path, Map <String,?>)``` — 
соответственно, для создания нового файла.
- Классы ```java.nio``` теперь имеют абсолютные (в отличие от относительных) ```get``` и ```set```-методы. 
Они, как и базовый абстрактный класс ```Buffer```, включают метод ```slice()``` для извлечения части буфера.
- В ```javax.xml.parsers``` добавлены методы для создания экземпляров фабрик DOM и SAX (с поддержкой пространств имен).
- Поддержка Unicode обновлена до версии 12.1.

[к оглавлению](#Java-Version-Features)

[Заглавная](README.md)