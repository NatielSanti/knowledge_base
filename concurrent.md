[Заглавная](README.md)

# Java Concurrent

+ [Проблемы многопоточки](concurrent.md#Проблемы-многопоточки)
+ [Основные характеристики Thread](concurrent.md#Основные-характеристики-Thread)
+ [Потоки через Runnable лучше](concurrent.md#Потоки-через-Runnable-лучше)

## Проблемы многопоточки

### ABA

Проблема с Атомиками. Текущий поток держит ссылку на `A` и хочет её перезаписать. 
В это время до `CAS` операции другой поток изменил значение `A` на `B`, а другой поток потом с `B` на `A`.
Когда наш поток придёт делать операцию CAS ссылка будет схожа с той прошлой, но не обязательно той же самой, 
возможно у неё будет изменено состояние. Для решения было создано `AtomicMarkableReference`.

### DCL

Double checked locking
 
```java
// Однопоточная версия
class Foo {
    private Helper helper = null;
    public Helper getHelper() {
        if (helper == null)
            helper = new Helper();
        return helper;
    }
    // и остальные члены класса…
}
```
Этот код не будет корректно работать в многопоточной программе. Метод `getHelper()` должен получать блокировку на случай,
 если его вызовут одновременно из двух потоков. Действительно, если поле `helper` ещё не инициализировано, 
 и одновременно два потока вызовут метод `getHelper()`, то оба потока попытаются создать объект, 
 что приведет к созданию лишнего объекта. Эта проблема решается использованием синхронизации, 
 как показано в следующем примере.
 
```java
// Правильная, но "дорогая" по времени выполнения многопоточная версия
class Foo { 
    private Helper helper = null;
    public synchronized Helper getHelper() {
        if (helper == null)
            helper = new Helper();
        return helper;
    }
    // и остальные члены класса…
}
```

Этот код работает, но он вносит дополнительные накладные расходы на синхронизацию. 
Первый вызов `getHelper()` создаст объект, и нужно синхронизировать только те несколько потоков, 
которые будут вызывать `getHelper()` во время инициализации объекта. 
После инициализации синхронизация при вызове `getHelper()` является излишней, 
так как будет производиться только чтение переменной. 
Так как синхронизация может уменьшить производительность в 100 раз и более, 
накладные расходы на блокировку при каждом вызове этого метода кажутся излишними: 
как только инициализация завершена, необходимость в блокировке отпадает. 
Многие программисты попытались оптимизировать этот код следующим образом:

1) Сначала проверяется, инициализирована ли переменная (без получения блокировки). Если она инициализирована, 
её значение возвращается немедленно.
2) Получение блокировки.
3) Повторно проверяется, инициализирована ли переменная, так как вполне возможно, 
что после первой проверки другой поток инициализировал переменную. Если она инициализирована, 
её значение возвращается.
4) В противном случае, переменная инициализируется и возвращается.

```java
// Некорректно работающая (в Symantec JIT и версиях Java 1.4 и ранее) многопоточная версия
// Шаблон "Double-Checked Locking"
class Foo {
    private Helper helper = null;
    public Helper getHelper() {
        if (helper == null) {
            synchronized(this) {
                if (helper == null) {
                    helper = new Helper();
                }
            }
        }
        return helper;
    }
    // и остальные члены класса…
}
```

На интуитивном уровне, этот код кажется корректным. Однако существуют некоторые проблемы 
(в версии `Java 1.4` и ранее и нестандартных реализациях `JRE`), которых, возможно, следует избегать. 
Представим себе, что события в многопоточной программе протекают так:

Поток А замечает, что переменная не инициализирована, затем получает блокировку и начинает инициализацию.
Семантика некоторых языков программирования такова, что потоку А разрешено присвоить разделяемой переменной 
ссылку на объект, который находится в процессе инициализации (что в общем-то вполне однозначно нарушает 
причинно-следственную связь, ведь программист вполне явно просил присваивать переменной ссылку на объект
(то есть — опубликовать ссылку в общий доступ) — в момент после инициализации, а не в момент до инициализации).
Поток Б замечает, что переменная инициализирована (по крайней мере, ему так кажется), 
и возвращает значение переменной без получения блокировки. 
Если поток Б теперь будет использовать переменную до того момента, когда поток А закончит инициализацию, 
поведение программы будет некорректным.
Одна из опасностей использования блокировки с двойной проверкой в `J2SE 1.4` (и более ранних версиях) состоит в том, 
что часто кажется, что программа работает корректно. Во-первых, рассмотренная ситуация будет возникать не очень часто;
 во-вторых, сложно отличить корректную реализацию данного шаблона от такой, которая имеет описанную проблему. 
 В зависимости от компилятора, распределения планировщиком процессорного времени для потоков, 
 а также природы других работающих конкурентных процессов, ошибки, 
 спровоцированные с некорректной реализацией блокировки с двойной проверкой, обычно происходят бессистемно. 
 Воспроизведение таких ошибок обычно затруднено.

Можно решить проблему при использовании `J2SE 5.0`. Новая семантика ключевого слова `volatile` даёт возможность 
корректно обработать запись в переменную в данном случае.

```java
// Работает с новой семантикой volatile
// Не работает в Java 1.4 и более ранних версиях из-за семантики volatile
class Foo {
    private volatile Helper helper = null;
    public Helper getHelper() {
        if (helper == null) {
            synchronized(this) {
                if (helper == null)
                    helper = new Helper();
            }
        }
        return helper;
    }
    // и остальные члены класса…
}
```
[к оглавлению](#concurrent.md)

## Основные характеристики Thread

Потоки могут быть объединены в группы, а те с свои группы. 
Это позволяет создавать иерархию и задавать верние и нижние границы приоритета потоков в группе.

```java
public static void main(String []args){
	Thread currentThread = Thread.currentThread();
	ThreadGroup threadGroup = currentThread.getThreadGroup();
	System.out.println("Thread: " + currentThread.getName());
	System.out.println("Thread Group: " + threadGroup.getName());
	System.out.println("Parent Group: " + threadGroup.getParent().getName());
}
```
Обработчик исключений.
```java
public static void main(String []args) {
	Thread th = Thread.currentThread();
	th.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
		@Override
		public void uncaughtException(Thread t, Throwable e) {
			System.out.println("Возникла ошибка: " + e.getMessage());
		}
	});
    System.out.println(2/0);
}
```

[к оглавлению](#concurrent.md)

## Потоки через Runnable лучше

- Вариант с потомком от Thread плох уже тем, что мы в иерархию классов включаем Thread. 
- Второй минус — мы начинаем нарушать принцип "Единственной ответственности" SOLID, т.к. 
наш класс становится одновременно ответственным и за управление потоком и за некоторую задачу, 
которая должна выполняться в этом потоке.
- А ещё Runnable является функциональным интерфейсом начиная с Java 1.8. 
Это позволяет писать код задач для потоков ещё красивее:

[к оглавлению](#concurrent.md)

[Заглавная](README.md)