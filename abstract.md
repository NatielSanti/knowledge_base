[Заглавная](README.md)

# Abstract
+ [Клонирование](abstract.md#Клонирование)
+ [Наследование](abstract.md#Наследование)
+ [Generics](abstract.md#Generics)
+ [Классы внутри классов](abstract.md#Классы-внутри-классов)
+ [Enum](abstract.md#Enum)
+ [Аннотации](abstract.md#Аннотации)
+ [Java 8 features](abstract.md#Java-8-features)
+ [String](abstract.md#String)


[hateoas]:img/hateoas.png

[к оглавлению](#Abstract)

## Клонирование

- Наследовать интерфейс Cloneable
- Deep and  Shallow clone
- Конструктор клонирования если есть `final` поля
- Клонирование через `super.clone()` не вызывает конструктора

[к оглавлению](#Abstract)

## Наследование

- Приватные поля тоже наследуются неявно. 
Потому что может использовать публичные сеттеры родителя.
- Наследование лучше не использовать, если наследник не является базовым классом. 
Принцип Барбары Лисков (`SOLID`). 
Например, не всегда можно заменить Прямоугольник дочерним классом Квадрат.
- порядок запуска блоков инициализации и конструкторов
- Позднее связывание (`dynamic binding`), когда мы вызываем переопределённый метод у наследника, 
а вызов статических методов - ранее связывание (`static binding`).
- аннотации могут быть анализированы компилятором, java agent, код
- при запуске компилятор поднимается в класс и ищет метод, если его нет, то идёт в родителя.
работает и для статических методов, хотя их нельзя переопределять. 
- Статические методы рекомендуется вызывать по имени класса, а не по ссылке, 
из-за shadowing (перекрытия) - для наследников статический метод класса скрывает 
одноименные статические методы с той же сигнатурой родительского класса.
- Чтобы вызвать метод дочернего класса из ссылки 
родительского класса необходимо будет сделать `Class cast`
- Статические методы нельзя переопределять нестатическими и наоборот
- Метод подстановки (опять Лисков) мы можем сузить тип возвращаемого 
значения в методе наследнике при переопределении
- для примитивных типов `Arrays.sort()` использует `QuickSort` (нестабильная сортировка), 
для ссылочных `TimSort` (стабильная сортировка)
- Стабильная сортировка это когда элементы сортируемого массива не меняют относительный порядок.
н-р при сортировке по чиловому ключу 
`{1, A} {3, B} {2, C} {2, A}` -> `{1, A} {2, C} {2, A} {3, B}`, 
а не в `{1, A} {2, A} {2, C} {3, B}`

[к оглавлению](#Abstract)

## Generics

- Внутри класса для дженериков можно использовать только методы класса `Object`, 
если нет ограничений
- Нужен для того, чтобы переложить ответственность за код с разработчика на компилятор. 
Так как дженерики позволяют ограничить применение каких-то типов и их методов, 
когда заранее неизвестно какой тип будет использоваться.
- c 7 версии при объявлении дженериков в создаваемом объекте можно использовать `<>` 
diamond systax, а в ссылке обязательно указывать конкретные, а не фиктивные типы вместо дженериков
- row generic - сырой дженерик, когда в параметризированный класс не определяется никакой тип в `<>`,
и автоматически туда подставляется тип `Object`
- Дженерики инвариантны, а массивы ковариантны. Первое, 
потому что дженерики не сохраняются отношение наследования, а массивы сохраняют
- Если мы используем сырой тип, то он может сломать работу дженерика, 
потому что они перетирают логику дженериков и делают эти объекты ковариантными
- стирание типов (Type erasing) - компилятор в ходе компиляции вычищает все дженерики 
и заменяет их `Object` либо в зависимости от ограничений дженерика
- Ссылки дженерика `<?> `нужны когда нам не важно что там лежит
- PECS -  в ссылки `<? extends Number>` нельзя ничего класть, но можно получать, а в ссылки типа 
`<? super Cat>` мы можем класть наследников `Cat`, но не может=м ничего получить.
**Producer Extends Consumer Super**
- параметризованные методы - если класс не использует дженерики, 
либо использует другие типы дженериков, то параметрезованные методы позволяют создать 
что-то типа своего контекста для этих дженериков в рамках этого метода.
- Нельзя создавать дженерик объекты - компилятор не знает объект какого типа 
нужно будет создавать и сколько места резервировать для объекта
- Параметризованные поля не могут быть статическими - 
потому что все объекты могут иметь доступ к статическому полю и не знают чего там ожидать.


[к оглавлению](#Abstract)

## Классы внутри классов

- `Nested` (вложенные) классы - статический класс внутри оборачивающего 
класса без привязки к стейту внешнего класса. 
Нет доступа к нестатическим полям оборачивающего класса
- `Inner` (внутренний) класс - нестатический класс внутри класса. 
Неявно хранит ссылку на объект оборачивающего класса. Объект не разразрывно связан с тем, 
что есть вокруг.
- Внешний и внутренний классы не обращают на модификаторы `private` друг друга
- `ConcurrentModificationException` может возникнуть в однопоточной среде, например, 
если мы создали итератор, потом сразу же очистили коллекцию, итератор не может быть уверен, 
что над его клиентов не проводили операции и может выбросить эту ошибку
- `fail-fast` это способность рано выбросить ошибку при возникновении затруднений
- nested весят меньше из-за отсутствия неявной ссылки на внешний объект. 
То есть если нет необходимости связывать обёртку и подсаженный класс, то используется nested
- Inner классы не могут содержать статических полей, кроме констант вычисляемых на этапе компиляции
- Подсаженные классы могут иметь наследников
- Подсаженные классы бывают локальные - 
объявляются внутри метода и только внутри него могут использоваться.
- Локальные классы не имеют области видимости и не могут использоваться выше строки его объявления
- Если наследник подсаженного класса находится в другом файле (другой области видимости), 
то он теряет доступ к полям вложенного для родителя класса
- подсаженные классы внутри интерфейсов всегда `Nested` (статические)
- анонимные классы это `Inner` классы, потому что имеют доступ к нестатическим полям родителя
- у анонимных классов нет дженериков и конструкторов


[к оглавлению](#Abstract)

## Enum

- Нужны для создания заданного ограниченного списка констант объектов, 
которые позволяют жестко ограничить возможные значения
- энам не могут иметь наследников
- наследуются все от `java.lang.Enum` и `java.lang.Comparable`
- могут реализовывать интерфейсы, но не могут быть абстрактными
- и их нельзя создавать
- они все public static final


[к оглавлению](#Abstract)

## Аннотации
- нужны как информация для компилятора(`@FunctionalInterface` не даст скомпилировать, 
если у интерфейса не 1 неопределённый интерфейс), 
для компиляции кода, обработка в рантайме
- джарник это архив 
- папку out можно запаковать в zip дать ей расширение jar и всё
- `@Target` - к чему эта аннотация может применяться
- `@Documented`  - аннотация применяется в javaDoc
- `@Retention` - кому доступна эта аннотация -  SOURCE, CLASS, RUNTIME
- рефлексия это апи, позволяющее в рантайме обратиться к JVM и получить метаинформацию.
Позволяет получить даже приватные методы и изменять финализированные поля.
- `@Deprecated`, `@Override`, `@SuppressWarnings` - стандартные аннотации
- Ломбок. Когда запускаем javac - он анализирует код (лексический, синтаксический, семантичекий)
и строит `AST(abstract syntax tree)` дерево. Если над каким то узлом висит аннотация, он смотрит, 
а есть ли процессор аннотаций, который отвечает за эту аннотацию? Если препроцессор нашелся, 
то компилятор отдаёт ему это дерево и он изменяет, добавляет, перестраивает это дерево.


[к оглавлению](#Abstract)

## Java 8 features

- Если класс наследует два интерфейса у которых есть методы с одинаковой сигнатурой - 
то это не нарушает контракт и компилятор ругаться не будет.
- Если класс реализует два интерфейса у которых есть дефолтные методы с одинаковой сигнатурой - 
то если мы переопределяем этот метод, то всё нормально, если не переопределяем, 
то компилятор ругнётся
- `@FunctionalInterface` это интерфейс с одним абстрактным методом, 
который не зависит от состояния реализующего объекта (`stateless`)
- Чистый метод - stateless, не зависит от состояния объекта, он принимает аргументы, 
совершает операцию и возвращает результат
- `@FunctionalInterface` компилятор проверяет, если в этот интерфейс добавить 
еще один абстрактный метод, то он ругнётся. И этот интерфейс точно можно использовать в лямбде
- лямбда это просто анонимная функция
- лямбды не создают отдельного класс файла. В момент обращения jvm его скомпилирует и загрузит.
- ссылки на методы бывают трёх типов - ссылка на статический и нестатический метод и на конструктор

[к оглавлению](#Abstract)

## String

- На брейкпоинтах происходит stop-the-world
- Alt+F8 evaluate запуск своего кода на брейкпоинте
- прямая рекурсия - когда метод вызывает сам себя может привести в StackOverflowException
- хвостовая рекурсия - когда вызов метода самого себя стоит в конце метода
- опосредованная, когда есть два метода поочередно вызывающие себя
- Сортировка слиянием (Merge Sort) - рекурсивно делим массив на пары элементов, 
а потом поднимаясь вверх сливаем мелкие массивы в более большие

[к оглавлению](#Abstract)

[Заглавная](README.md)
