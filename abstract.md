[Заглавная](README.md)

# Abstract
+ [Быстрый старт](abstract.md#Быстрый-старт)
+ [Примитивы](abstract.md#Примитивы)
+ [Операторы](abstract.md#Операторы)
+ [Клонирование](abstract.md#Клонирование)
+ [Наследование](abstract.md#Наследование)
+ [Generics](abstract.md#Generics)
+ [Классы внутри классов](abstract.md#Классы-внутри-классов)
+ [Enum](abstract.md#Enum)
+ [Аннотации](abstract.md#Аннотации)
+ [Java 8 features](abstract.md#Java-8-features)
+ [String](abstract.md#String)
+ [Collections](abstract.md#Collections)
---
+ [Thread group](abstract.md#Thread-group)
+ [Thread](abstract.md#Thread)
+ [Executor](abstract.md#Executor)
+ [Callable and Future](abstract.md#Callable-and-Future)
+ [Locks](abstract.md#Locks)
+ [ArrayBlockingQueue](abstract.md#ArrayBlockingQueue)
+ [Atomic](abstract.md#Atomic)
+ [ConcurrentCollections](abstract.md#ConcurrentCollections)
---
+ [Интерфейсы](abstract.md#Интерфейсы)
+ [Лямбды](abstract.md#Лямбды)
---
+ [Дополнение](abstract.md#Дополнение)

[hateoas]:img/hateoas.png
[volatile]:img/concurrent/volatile.png
[skip-list]:img/concurrent/skip-list.png

[к оглавлению](#Abstract)

## Быстрый старт

- Пустая строка в конце класса - хороший тон
- Лексический анализ - разбивка кода на лексемы (конструкции языка). Просто проверка слов
- Синтаксический анализ - проверка того что набор слов (лексема) что-то значит. 
Порядок слов, точки с запятой
- Семантический анализ - проверка смысла программы. Инициализация локальных переменных, 
наследование методов
- javac - компилятор. `*.java` - нескомпилированный файл. `*.class` - скомпилированный байткод файл
- в директории `src` лежат исходники. `out` - байткод
- импорт пакетов через звёздочку не позволяет понять где точно лежит класс, 
поэтому лучше использовать полный импорт
- `int` занимает 4 байта
- `header` 32 разрядной - 8 байт, у 64 разрядной - 12 байт
- `padding` выравнивание объёма до кратной 8.
- `reference` 32 разрядной - 4 байт, у 64 разрядной - 8 байт
- `array` заголовок + 4 байта на длину массива 
- `Java` статически типизированный язык - он знает какие методы и поля есть у классов заранее

[к оглавлению](#Abstract)

## Примитивы

- Значения по умолчанию не применимы к локальным переменным - потому что байткод,
который будет создан, работает со стеком и выходит локальная переменная, 
без значения ничего не кладёт на стек, а он тупой и всё сломается.
- Типы переменных - локальная, статическая и динамическая
- У `short` есть отрицательные значения, а у `char` нет, и хотя они оба занимают 2 байта информации - 
безопасно преобразовывать их друг к другу нельзя
- Если пользуешься дробными числами лучше использовать `double` из-за большей точности
- Все результаты операций преобразуются в `int` потому что на стек машина использует `int`
- Слишком большое дробное число при приведении к целому преобразется в 
`Integer.MAX_VALUE` или `Integer.MIN_VALUE`
- Слишком большой `double` при попытке преобразования во `float` превращается в бесконечность
- Классы оболочки для примитивов являются иммутабельными
- Передача в методы по значению

[к оглавлению](#Abstract)

## Операторы

- Оператор не `~` просто инвертирует число в битовом отображении. 
Чтобы получить отрицательное число целого положительного нужно его инвертировать и -1
- `FPU - floating point unit` сопроцессор для работы с числами с плавающей точкой. 
В разных процессорах результат может быть немного разный. Для этого есть ключевое слово `strictfp`

[к оглавлению](#Abstract)

## Клонирование

- Наследовать интерфейс Cloneable
- Deep and  Shallow clone
- Конструктор клонирования если есть `final` поля
- Клонирование через `super.clone()` не вызывает конструктора

[к оглавлению](#Abstract)

## Наследование

- Приватные поля тоже наследуются неявно. 
Потому что может использовать публичные сеттеры родителя.
- Наследование лучше не использовать, если наследник не является базовым классом. 
Принцип Барбары Лисков (`SOLID`). 
Например, не всегда можно заменить Прямоугольник дочерним классом Квадрат.
- порядок запуска блоков инициализации и конструкторов
- Позднее связывание (`dynamic binding`), когда мы вызываем переопределённый метод у наследника, 
а вызов статических методов - ранее связывание (`static binding`).
- аннотации могут быть анализированы компилятором, java agent, код
- при запуске компилятор поднимается в класс и ищет метод, если его нет, то идёт в родителя.
работает и для статических методов, хотя их нельзя переопределять. 
- Статические методы рекомендуется вызывать по имени класса, а не по ссылке, 
из-за shadowing (перекрытия) - для наследников статический метод класса скрывает 
одноименные статические методы с той же сигнатурой родительского класса.
- Чтобы вызвать метод дочернего класса из ссылки 
родительского класса необходимо будет сделать `Class cast`
- Статические методы нельзя переопределять нестатическими и наоборот
- Метод подстановки (опять Лисков) мы можем сузить тип возвращаемого 
значения в методе наследнике при переопределении
- для примитивных типов `Arrays.sort()` использует `QuickSort` (нестабильная сортировка), 
для ссылочных `TimSort` (стабильная сортировка)
- Стабильная сортировка это когда элементы сортируемого массива не меняют относительный порядок.
н-р при сортировке по чиловому ключу 
`{1, A} {3, B} {2, C} {2, A}` -> `{1, A} {2, C} {2, A} {3, B}`, 
а не в `{1, A} {2, A} {2, C} {3, B}`
- Ромбовидное наследование, которого нет в Java состоит из наследования состояния (поля)
и дублирование поведения (методы).

[к оглавлению](#Abstract)

## Generics

- Когда он нужен? Когад у вас есть общая функциональность, 
но в некоторых случаях она может отличаться от типа к типу. Либо вы хотите более типобезопасно работать.
То есть при начальной инициализации работать только с определённым типом.
- Внутри класса для дженериков можно использовать только методы класса `Object`, 
если нет ограничений
- Нужен для того, чтобы переложить ответственность за код с разработчика на компилятор. 
Так как дженерики позволяют ограничить применение каких-то типов и их методов, 
когда заранее неизвестно какой тип будет использоваться.
- c 7 версии при объявлении дженериков в создаваемом объекте можно использовать `<>` 
diamond systax, а в ссылке обязательно указывать конкретные, а не фиктивные типы вместо дженериков
- row generic - сырой дженерик, когда в параметризированный класс не определяется никакой тип в `<>`,
и автоматически туда подставляется тип `Object`
- Дженерики инвариантны, а массивы ковариантны. Первое, 
потому что дженерики не сохраняются отношение наследования, а массивы сохраняют
- Если мы используем сырой тип, то он может сломать работу дженерика, 
потому что они перетирают логику дженериков и делают эти объекты ковариантными
- стирание типов (Type erasing) - компилятор в ходе компиляции вычищает все дженерики 
и заменяет их `Object` либо в зависимости от ограничений дженерика. 
Это нужно для обратной совместимости языка
- Ссылки дженерика `<?> `нужны когда нам не важно что там лежит
- PECS -  в ссылки `<? extends Number>` нельзя ничего класть, но можно получать, а в ссылки типа 
`<? super Cat>` мы можем класть наследников `Cat`, но не может=м ничего получить.
**Producer Extends Consumer Super**
- параметризованные методы - если класс не использует дженерики, 
либо использует другие типы дженериков, то параметрезованные методы позволяют создать 
что-то типа своего контекста для этих дженериков в рамках этого метода.
- Нельзя создавать дженерик объекты - компилятор не знает объект какого типа 
нужно будет создавать и сколько места резервировать для объекта
- Параметризованные поля не могут быть статическими - 
потому что все объекты могут иметь доступ к статическому полю и не знают чего там ожидать.
- Нельзя параметризовать наследников `Throwable`, ENUM, анонимные классы. 
Потому что будет непонятно в какой catch блок отлавливать параметризованную ошибку после стирания типов. 
н-р `Comparable<Person>`.
Потому что ENUM создаются сразу после компиляции программы строго определённых типов.
Потому что экземпляр анонимного класса только один.

- `Ковариантность возвращаемого значения` это про полиморфизм, когда мы сужаем тип возвращаемого значения в потомке
- Все локальные переменные и все незафиксированные переменные-дженерики - стираются в левую границу. 
- Если есть какая-то метаинформация. н-р Статические поля-дженерики или определённые при наследовании дженерики, 
возвращаемые значения - то эта информация в рантайме сохранится и можно её вытащить.
- `Bridge method` методы генерируемые JVM для перенаправления метода с типом `Object` в метод с дженериком.
- `CheckedList` нужны как раз для борьбы с использованием сырых дженериков. Они запоминают класс тип, 
который хранит эта коллекция, для дальнейшей проверки.
- Если метод использует дженерики, то ссылка может заказывать тип дженерика. В примере ниже -
в метод `getList()` вместо `T` заказывается `Number`
```java
public class Example {
    @Test
    void test(){
        Number list = getList(); // Number list = Example<Number>.getList();
    } 
    
    private static <T extends List<String>> T getList(){
        return (T) new ArrayList<String>();
    }
}
```

[к оглавлению](#Abstract)

## Классы внутри классов

- `Nested` (вложенные) классы - статический класс внутри оборачивающего 
класса без привязки к стейту внешнего класса. 
Нет доступа к нестатическим полям оборачивающего класса
- `Inner` (внутренний) класс - нестатический класс внутри класса. 
Неявно хранит ссылку на объект оборачивающего класса. Объект не разразрывно связан с тем, 
что есть вокруг.
- Внешний и внутренний классы не обращают на модификаторы `private` друг друга
- `ConcurrentModificationException` может возникнуть в однопоточной среде, например, 
если мы создали итератор, потом сразу же очистили коллекцию, итератор не может быть уверен, 
что над его клиентов не проводили операции и может выбросить эту ошибку
- `fail-fast` это способность рано выбросить ошибку при возникновении затруднений
- nested весят меньше из-за отсутствия неявной ссылки на внешний объект. 
То есть если нет необходимости связывать обёртку и подсаженный класс, то используется nested
- Inner классы не могут содержать статических полей, кроме констант вычисляемых на этапе компиляции
- Подсаженные классы могут иметь наследников
- Подсаженные классы бывают локальные - 
объявляются внутри метода и только внутри него могут использоваться.
- Локальные классы не имеют области видимости и не могут использоваться выше строки его объявления
- Если наследник подсаженного класса находится в другом файле (другой области видимости), 
то он теряет доступ к полям вложенного для родителя класса
- подсаженные классы внутри интерфейсов всегда `Nested` (статические)
- анонимные классы это `Inner` классы, потому что имеют доступ к нестатическим полям родителя
- у анонимных классов нет дженериков и конструкторов


[к оглавлению](#Abstract)

## Enum

- Нужны для создания заданного ограниченного списка констант объектов, 
которые позволяют жестко ограничить возможные значения
- энам не могут иметь наследников
- наследуются все от `java.lang.Enum` и `java.lang.Comparable`
- могут реализовывать интерфейсы, но не могут быть абстрактными
- и их нельзя создавать
- они все public static final


[к оглавлению](#Abstract)

## Аннотации
- нужны как информация для компилятора(`@FunctionalInterface` не даст скомпилировать, 
если у интерфейса не 1 неопределённый интерфейс), 
для компиляции кода, обработка в рантайме
- джарник это архив 
- папку out можно запаковать в zip дать ей расширение jar и всё
- `@Target` - к чему эта аннотация может применяться
- `@Documented`  - аннотация применяется в javaDoc
- `@Retention` - кому доступна эта аннотация -  SOURCE, CLASS, RUNTIME
- рефлексия это апи, позволяющее в рантайме обратиться к JVM и получить метаинформацию.
Позволяет получить даже приватные методы и изменять финализированные поля.
- `@Deprecated`, `@Override`, `@SuppressWarnings` - стандартные аннотации
- Ломбок. Когда запускаем javac - он анализирует код (лексический, синтаксический, семантичекий)
и строит `AST(abstract syntax tree)` дерево. Если над каким то узлом висит аннотация, он смотрит, 
а есть ли процессор аннотаций, который отвечает за эту аннотацию? Если препроцессор нашелся, 
то компилятор отдаёт ему это дерево и он изменяет, добавляет, перестраивает это дерево.


[к оглавлению](#Abstract)

## Java 8 features

- Если класс наследует два интерфейса у которых есть методы с одинаковой сигнатурой - 
то это не нарушает контракт и компилятор ругаться не будет.
- Если класс реализует два интерфейса у которых есть дефолтные методы с одинаковой сигнатурой - 
то если мы переопределяем этот метод, то всё нормально, если не переопределяем, 
то компилятор ругнётся
- `@FunctionalInterface` это интерфейс с одним абстрактным методом, 
который не зависит от состояния реализующего объекта (`stateless`)
- Чистый метод - stateless, не зависит от состояния объекта, он принимает аргументы, 
совершает операцию и возвращает результат
- `@FunctionalInterface` компилятор проверяет, если в этот интерфейс добавить 
еще один абстрактный метод, то он ругнётся. И этот интерфейс точно можно использовать в лямбде
- лямбда это просто анонимная функция
- лямбды не создают отдельного класс файла. В момент обращения jvm его скомпилирует и загрузит.
- ссылки на методы бывают трёх типов - ссылка на статический и нестатический метод и на конструктор

[к оглавлению](#Abstract)

## String

- На брейкпоинтах происходит `stop-the-world`
- Alt+F8 evaluate запуск своего кода на брейкпоинте
- прямая рекурсия - когда метод вызывает сам себя может привести в `StackOverflowException`
- хвостовая рекурсия - когда вызов метода самого себя стоит в конце метода
- опосредованная, когда есть два метода поочередно вызывающие себя
- Сортировка слиянием (Merge Sort) - рекурсивно делим массив на пары элементов, 
а потом поднимаясь вверх сливаем мелкие массивы в более большие
- Кодировка состоит из 1) это таблица в которой записан символ и соответствующее ему 
число 2) последовательность бит, которое будет представлять символ
- `CharSequence` - базовый интерфейс для `String`, `StringBuilder`, `StringBuffer`
- метод `charAt` может выдать неправильный результат, 
если символ является составным из расширенной таблицы, лучше использовать `codePointAt`
- `intern()` jvm пробегает по пулу строк и возвращает ссылку на объект из пула строк, 
либо помещает его в пул строк
- неразрывный пробел для `trim()` не является пробельным символом. Alt + 2 5 5
- `StringBuilder` and `StringBuffer` не переопределяют методы `equals()` и `hashCode()`
- дефолтная ёмкость `StringBuilder` = 16 символов + длина начальнйо строки
- паттерн Строитель нужен для борьбы с телескопическими конструкторами и fail-fast поведения
- Строковое представление null = "null"
- `+` переопределен только для строк
- в `printf` индексация с нуля
- интернирование происходит во время компиляции
- До 7 java пул строк был в пермгене, а значит его можно было заполнить, сделать Memory Leak. 
С 7 версии пул строк находится в куче и подвергается проверке сборщиком мусора
- Дедупликация вместо интернирования. Делает по факту то же самое что и интернирование, 
но необходимо включить специальные флаги для JVM и подключить G1 GC.

[к оглавлению](#Abstract)

## Collections

- `HashMap` корзина вычисляется по формуле - `(n - 1) & hash(key)`. `n` - текущее количество корзин, 
всегда степень двойки. Пример - `10000 - 1 & hash(key) = 1111 & hash(key)` корзина всегда выйдет 
меньше чем `capacity`  мапы. Обеспечивается равномерное распределение.
- `TREEIFY_CAPACITY` - число нод, после которого происходит перестроение 
связного списка в бинарное дерево.  `По-умолчанию - 8`, но перестройка идёт 
только если таблица больше чем `MIN_TREEIFY_CAPACITY` (по-умолчанию 64), 
а иначе просто увеличит `capacity`
- `load_factor` (Н-р 0.75) процент заполненности мапы до увеличения `capacity` вдвое

[к оглавлению](#Abstract)

## Thread group

- Сейчас TreadGroup используются только для группировки потоков:
  - общее имя, отслеживания количества живых потоков и отправки им сигнала на остановку.
  - назначение общего `ExceptionHandler`
- Поток вызывающий метод `join()` у другого потока ставится на паузу. 
Но если вызвать `join(500)` (с временем) может вызвать неожиданную 
проблему - неясно ожидание завершилось по причине завершения 
присоединённого потока или из-за ошибки в нём
- Методы `getName()`, `getMaxPriority()`, `getParent()`, `activeCount()`, 
`activeGroupCount()`
- `destroy()` лучше вызывать у групп с законченными потоками, 
чтобы освободить ссылки на сами потоки. Также нельзя добавлять новые потоки в 
группу после использования этого метода. Можно вызвать метод `destroy()` автоматически,
если пометить группу как демон `setDaemon(true)`.
- Потоки из разных групп не могут друг на друга действовать, например, вызвать метод
`interrupt()` из потока группы А в поток группы Б. Для этого есть метод `checkAccess()`,
который проверяет настройки `SecurityManager` на наличие прав, но `SecurityManager` в 
современных приложениях почти не используется.

[к оглавлению](#Abstract)

## Thread

### Потоки демоны
- Создаваемый новый поток наследует от родителя только группу.
- Приложение работает до тех пор, пока есть хотя бы один живой не-демон поток.
- Потоки-демоны не влияют на длительность жизни приложения (работы JVM). 
Из-за этого в потоки-демоны нельзя помещать логику изменяющую состояние, н-р запись в файл.
Так же даже логика в блоке `finally` может не выполниться. Во всё остальном это обычные потоки.
- Потоки-демоны используются н-р в логировании. Это сервисные потоки.

### interrupt()
- `interrupt()` руководствуется механизмом ***Коллективной ответственности*** - 
то есть не только поток вызвавший метод решает что другой поток надо прервать, 
но и прерываемый поток тоже должен подтвердить, что он готов прерваться.
- `isInterrupted()` - проверяет значение "флажка" (прервал ли кто меня), 
а `interrupted()` после вызова скидывает флажок обратно.

### volatile

- `atomacity` Помогает только для атомарного чтения и записи 
- `visibility` Гарантирует актуальность значения
- вешается на поля, чтобы значение поля не кешировалось в цп.
- `volatile` не спасает от `race condition`
- `критическая секция` - позволяет выполнять блок атомарно
- Чтение и запись атомарность гарантируется для примитивов кроме `long` и `double`. 
- Чтение и запись ссылочных тоже атомарна
- Барьер **IRIW** `Independent Read Independent Write`

![icon][volatile]

### synchronized

- у каждого объекта в хипе в заголовке есть монитор. 2 бита на хранение монитора. 
Один бит - просто захват, а второй - **biased**. Также в заголовке указан идентификатор потока, 
захватившего монитор. У каждого монитора есть `entry set` (очередь на захват монитора) 
и `waiting set` (сет тредов, остановившихся на этом мониторе).
- **race condition** - случай когда в критическую секцию одновременно заходят два или 
более потоков и от порядка операций будет зависеть результат. 
Чтобы этого избежать необходимо использовать мониторы. Два типа **race condition**
  - check and action
  - read and modify
- перед блоком либо перед методом
- приоритет потока не влияет на приоритет выдачи монитора объекта. 
В каком порядке потоки пришли к монитору не играет роли - зависит от реализации JVM.
- **starvation** - ситуация, когда поток раз за разом проигрывает розыгрыш на ресурс
  - вход в монитор
  - квант времени процессов
  - воркерам
  - по памяти
- Если какая-то операция может вызвать `InterruptedException`, но к тому момент флажок 
`isInterrupted` уже проставлен, то ошибка будет вызвана до того как JVM приступит к этой операции
- При сравнении примитива и враппера - враппер разворачивается и сравниваются два примитива.
- Не стоит синхронизироваться на врапперах. 
Потому что каждый раз будет происходить захват мониторов разных объектов. 
И еще врапперы будут шариться по всему приложению и может произойти 
синхронизация разных частей приложения по одному врапперу.
- несинхронизованные блоки могут работать одновременно с синхронизованными, 
потому что несинхронизованные методы даже не смотрят на монитор объекта 
и не проверяют его занятость.
- методы с `synchronized` согласно поведению happens-before всегда возвращают 
в память актуальные значения переменных, но несинхронизованные методы 
могут видеть неактуальные данные и поэтому при работе одновременно синхронизованных 
и несинхронизованных методов необходимо использоваться для переменных ключевое слово `volatile`.
- Чтение и запись в `volatile` перемнные дешевле чем вхо и выход в блоки `synchronized`
- Вместо объектов с `synchronized` методов в качестве мониторов
лучше использовать приватные объекты мониторы. 
Потому что сторонний метод так же может использовать монитор вашего объекта.
Тогда внутри этого объекта лучше создать приватный лок-объект и на нём синхронизироваться.
Хотя вместо приватного синхронизационного объекта можно использовать аннотации `Ломбока`.
- Так же синхронизированные методы могут быть переопределены в 
наследниках класса как несинхронизованные, что может вызвать проблемы. 
- абстрактные `Synchronized` методы и `Synchronized` методы в интерфейсах запрещены потому что 
ключевое слово `Synchronized` ни к чему не обязывает
- решение `dead lock`:
  - выбор ресурсов по приоритету
  - наличие арбитра, распределяющего ресурсы 
- Для моделирования многопоточки можно использовать `Сети Петри`

### wait(), notify(), notifyAll()

- `wait(), notify(), notifyAll()` можно выполнить только владея монитором этого объекта 
в рамках критической секции
- После того как поток разбудили он опять становится в очередь на захват монитора, 
чтобы продолжить выполнение в рамках критической секции
- Когда мы вызываем `wait()`, то по документации мы должны обрамлять его в 
`while(isCondition()){}` по условию из-за самопроизвольного пробуждения
- `notify()` переводит потоки `waiting set` в `entry set`

### suspend(), resume(), stop()

- Устаревшие, лучше не использовать. `suspend():void` не меняет состояния потока. 
Разнесённая логика, плюс вызывает другим потоком. 
  - Плюс он не отпускает монитор объекта, а значит это может привести к `deathlock`.
  - Логика паузы и запуска потоков может быть разнесена по коду
- `Thread.holdsLock(obj):boolean` проверяет держит ли поток монитор объекта
- `stop(obj)` - был, но выпилен. `stop()` - останавливает поток в случайном месте, 
что может произвести ошибки. В общем лучший подход - отдать управление самому потоку, 
чтобы он решал когда остановиться, чем управлять им снаружи. 
Его можно проигнорировать и в этом проблема. Лучше использовать механизм `interrupred()`.

[к оглавлению](#Abstract)

## Executor

- Интерфейс позволяющая отдать контроль над порождением и управлением потоками. 
Создание и уничтожение потоков дорогая операция. Это не `функциональный интерфейс`, 
потому что они должны быть `stateless`.
- `ExecutorService.shutdown()":void` - неблокирующий метод, то есть все задачи, 
что в очереди на выполненеи завершатся, но новые `runnable` не добавятся в очередь
`RejectedExecutionException`. Вызывающий поток дальше выполняет свою задачу.
- `ExecutorService.awaitTermination(Long, TimeUnit):void` - поток вызывающий задачу 
ждёт что завершится скорее - таймаут или выполнение всех задач и только потом 
продолжает выполнение. Блокирующий метод.
- `ExecutorService.shutdownNow():List<Runnable>` - возвращает невыполненные задачи 
и останавливает `ExecutorService`
- `SchedulerThreadPoolExecutor`, `ThreadPoolExecutor`, `ForkJoinPool` - основные реализации, 
которые используются разработчиками

### Executors

- Создание новых потоков дорогая операция. Смысл этих сервисов в переиспользовании потоков.
Еще `ExecutorService` можно перенастраивать на ходу. В этом опасность, 
если кто-то получит ссылку на этот `ExecutorService`, то он может изменить его конфигурацию.
Чтобы этого избежать можно использовать `Executor.unconfigurableExecutorService(var)`, 
создаёт декоратор, который препятствует изменению конфигурации сервиса
- `Executors` это набор статических методов, который 
создаёт `ThreadPoolExecutor` с разными параметрами.
- `Executors.newFixedThreadPool(int n)` - создание фиксированного пула потоков. 
Если потоков больше чем задач, то
какие-то потоки простаивают, если задач больше потоков - задачи сидят в очереди. 
`n` может меняться в зависимости от задач и количества ядер процессора.
- `Executors.newCachedThreadPool()` - если в пуле нет потоков для выполнения новой задачи - 
они создаются, затем помещаются в кеш заново, для переиспользования. 
Хорош, когда баланс между количеством задач и временем выполнения. 
Если накидать одновременно 1000 задач, то он создаст 1000 потоков. Надо понимать, 
сколько максимум задач в пике может собраться на очереди к выполнению.
- `corePoolSize` - стартовое количество потоков, ниже которого 
их количество не опустится в процессе работы `ExecutorService`
- `maxPoolSize` - максимальное количество создаваемых потоков
- `keepAliveTime`, `TimeUnit` - сколько времени потоки могут жить без задач
- `BlockingQueue<Runnable>` - куда помещаются `runnable` и откуда потоки 
берут задачи на выполнение. По-умолчанию `Synchronous<Runnable>`
- `ThreadFactory` - фактори, создающая потоки для `Executor`. Нужен для настройки 
отдаваемого создаваемого потока
- `RejectedExecutionService` - как `ExecutorService` будет отвечать 
на попытки добавить новую задачу после получения команды `shutdown()`
- `SchedulerThreadPoolExecutor` в дополнение к стандартным методам `ExecutorService` 
  - `schedule()` позволяет создавать отсроченные задачи . 
  - `scheduleWithFixedDelay()` - периодически выполнять одну задачу спустя время 
  после завершения предыдущей
  - `scheduleAtFixedRate()` - периодически выполнять задачу вне 
  зависимости от завершения предыдущей
- `Executors.callable(Runnable runnable):Callable<Void>` оборачивает одно в другое 
для совместимости

[к оглавлению](#Abstract)

## Callable and Future

- `ExecutorService` имеет так же метод `submit(X):Future<Y>`, который принимает 
`Callable<A>` и `Runnuble`. Не блокирующий
- `Future<A>` что-то типа обязательства на получение результата.
- `Future.get()` блокирующая операция

[к оглавлению](#Abstract)

## Locks

- Локи избавляют от нечестной конкуренции за ресурс.
- `unlock()` необходимо делать в блоке `finally`, а `lock()` оставить за пределами блока `try`,
потому что в случае исключения будет вызван `unlock()` при том, что мы не захватили лок, 
то есть в случае с `ReentrantLock` это уменьшит значение блокировок, без увеличения её.
```java
Lock lock = new ReentrantLock();
lock.lock();
try {
    // action    
} finally {
    lock.unlock();    
}
```
- `lock.interruptable()` в отличии от критической секции, который кидает поток в состояние 
`BLOCKED`, это метод позволяет потоку выйти при получении команды `interrupt()`, 
но с необходимостью обработать `InterruptedException`
- `lock.tryLock():boolean` пробует захватить монитор
- `ReentrantLock(boolean)` честный или нечестный розыгрыш лока. Честный медленнее. 
С выключенным параметров `ReentrantLock()` быстрее критического блока, 
с включенным - медленнее
- `ReentrantReadWriteLock implement ReadWriteLock` - реализация лока для блокировок 
по чтению и записи отдельно. Тоже может быть честным или нечестным.
```java
class App {
    private final Lock readLock;
    private final Lock writeLock;
    private String storage;
    
    public App(){
        ReadWriteLock lock = new ReentrantReadWriteLock();
        readLock = lock.readLock();
        writeLock = lock.writeLock();
    }
    
    @SneakyThrow
    public String read(){
        readLock.lock();
        try {
            TimeUnit.SECONDS.sleep(1);
            return storage;
        } finally {
            readLock.unlock();
        }
    }

  @SneakyThrow
  public String write(String newValue){
    writeLock.lock();
    try {
      TimeUnit.SECONDS.sleep(2);
      storage = newValue;
    } finally {
      writeLock.unlock();
    }
  }
} 
```
- `lock.newCondition():Condition`. `Condition` это абстракция над механизмом `wait-notify`.
  - Плюсы в том, что не нужно владеть монитором объекта, на котором происходит `wait()`
  - не ограничены критической секцией (это одновременно и минус)
  - возможно будить НЕ только один поток или все объекты, а лишь часть потоков по какому-то принципу

[к оглавлению](#Abstract)

## ArrayBlockingQueue

- фиксированный размер, честная\нечестная
- три метода на добавление / удаление-получение
  - `add()`, `remove()` - бросает ошибку
  - `offer():boolean`, `poll()`- возвращает результат успешности добавления
  - `put()`, `take()` - блокируемая
- методы для получения без модификации `peek()`, `element()` 

[к оглавлению](#Abstract)

## Atomic

- `CAS` операции - Compare ans Set. За одну неделимую операцию сделать 3 действия:
  - Обращение к участку памяти и проверка его значения
  - Сравнение того что лежит с тем, что вы предоставляете после операции
  - Если то что ожидали и то что предоставили совпадают то идёт запись
- Подвержен `ABA` проблеме. Не проблема если работа идёт с примитивом, а если со ссылкой, 
то теряется гарантия того, что ссылка указывает на тот же самый объект, а не равный ему.
Решается при помощи  `AtomicStampedReference<A>` и `AtomicMarkableReference<A>`. В блоке `do` 
нежелательно делать дорогих операций
```java
private static final AtomicLong VALUE = new Atomic();
long actual;
do {
    actual = VALUE.get();
} while(!VALUE.compareAndSet(actual, actual - 1));
```
- ##### CAS операция хороша когда конкуренция между потоками не такая большая, выгоднее просто использовать блокировки
- `AtomicFloat` и `AtomicDouble` нет. Но можно решить с помощью 
`Float.floatToIntBits(1f);`, использовать `AtomicInteger` (оба занимают 4 байта), 
а потом сконвертировать обратно. так же можно написать свой класс обёртку с операцией 
`compareAndSet()`
- `AtomicIntegerFieldUpdater` необходим для атомарного изменения поля в существующем классе 
(н-р библиотечный класс). Поле должно быть доступным и `volatile`.
- `AtomicMarkableReference<A>` есть поле `boolean mark`, которое меняется 
с true на false и обратно. Это помогает как-то уопрядочить и проверять наличие проблемы `ABA`.
Имеет только 2 состояния.
- `AtomicStampedReference<A>` позволяет поддерживать больше чем два состояния. Встроен счетчик.
- `LongAdder` хранит массив изменений и каждый поток по хэшу может работать 
со своим элементов массива. Когда приходит очередь операции `get()`,
то все накопленные изменения суммируются и выдаётся результат. Размер  массива по количеству ядер.
Это самый оптимальный  способ записи значений из нескольких потоков в одно хранилище.


[к оглавлению](#Abstract)

## ConcurrentCollections

- `LongAccumulator` почти то же самое, что `LongAdder`, но на вход принимает
  функцию (ассоциативную операцию, не зависящую от порядка слагаемых) и начальное значение
- `ConcurrentHashMap` - локи по корзине, а точнее на верхней ноде списка или древа этой корзины
- `ConcurrentSkipListMap` в среднем случае даёт логарифмическую скорость поиска элементов, 
так как они упорядочены. Новые уровни создаются рандомизированно - при добавлении элемента 
решается с вероятностью 50% - будет ли этот элемент отображаться на уровень выше. 
У каждой ноды три ссылки - ссылка вперёд, ссылка назад, ссылка на корень где значение. 
В многопоточке блокироваться в `ConcurrentSkipListMap` можно по секторам и секторам, 
у которых есть ссылка на изменяемый сектор.
  ![icon][skip-list]

[к оглавлению](#Abstract)

## Интерфейсы

### Методы по умолчанию

- Методы по умолчанию предназначены для расширения существующих интерфейсов новыми возможностями
  - Методы по умолчанию позволяют избежать создания служебных классов. 
  Все необходимые методы могут быть представлены в самих интерфейсах.
  - Методы по умолчанию дают свободу классам выбрать методы, которые нужно переопределить.
  - Методы по умолчанию не могут переопределить методы класса `Object`
  - Методы по умолчанию низший приоритет при переопределении
- Если ниже по иерархии (в наследниках) есть абстрактный метод с данной сигнатурой, 
то насоедники будут требовать реализацию, несмотря на наличие дефолтного метода
- Видимо при наследовании идёт рекурсивный поиск реализации абстрактных методов по всем ветвям. 
И даже если в одной ветке до самой глубины этот метод не определён, а по другой ветке определён, 
то JVM этого хватает.
- Планировалось, что методы по умолчанию это способ добавления новых методов 
с поддержанием обратной совместимости. Могут возникнуть проблемы, 
когда у родителей появилось независимо два метода с одинаковой сигнатуро - 
компилятор не будет знать что какую реализацию выбрать. 
В таком случае лучше никогда не наследоваться от двух библиотечных родителей, 
а создать два независимых потомка и агрегировать их как-то.
- `Функциональные интерфейсы` имеют только 1 абстрактный метод, а еще они `stateless`, 
то есть не зависит от состояния объекта, реализующего этот интерфейс

---

### Binary compatibility

- `binary compatibility` - бинарная совместимость - какие изменения вы можете 
вносить в ваш байткод без необходимости перекомпиляции.
  - Изменение реализации существующих методов, конструкторов, блоков инициализации
  - Добавление новых полей, методов, конструкторов в интерфейсам и классам
  - Удаление приватных полей, методов, контрукторов класса
  - Перемещенеи методов наверх по иерархии класса
  - Добавление новых классов и интерфейсов

[к оглавлению](#Abstract)

## Лямбды

[к оглавлению](#Abstract)

## Дополнение

- `Runtime.getRuntime().availableProcessors()` - количество доступных JVM процессоров
- Пользоваться одним `Runnable` для создания нескольких разных потоков нормально,
  при условии, что они `stateless`
- `busy way` - цикл с опросом. Н-р `while(true){}` бесконечно опрашивает и
  процессор делает бесполезную работу
- Решение атомарности по `оптимальности` решения:
  - `volatile` + `synchronized`
  - `volatile` + `locks`
  - `AtomicLong`, `AtomicInteger`
  - `AtomicAdder`
- Разные ассоциативные массивы в многопоточке
  - `HashTable` -  все методы `synchronized` на самой `HashTable`
  - `SynchronizedHashMap` - блокировки на локе.
  - `HashMap` не должна использоваться в многопоточке
  - `CuncurrentHashMap` - блокировки на уровне бакетов
- `ThreadLocal` когда поток обращается к такой переменной он видит только
уникальное значение для себя, хотя объект может быть один и тот же для всех потоков.
Внутри `ThreadLocal` мапа, где в качестве ключа - поток.
Их опасно использовать с CachedPool, потому что значения могут перезатираться 
из-за переиспользования потоков.
- `ThreadLocalRandom` объект `Random` на основе `ThreadLocal`
- `Exchanger<T>` двусторонний обменник, а `SyncronousQueue` - односторонний

[к оглавлению](#Abstract)

[Заглавная](README.md)
