[Заглавная](README.md)

# Abstract
+ [Быстрый старт](abstract.md#Быстрый-старт)
+ [Примитивы](abstract.md#Примитивы)
+ [Операторы](abstract.md#Операторы)
+ [Клонирование](abstract.md#Клонирование)
+ [Наследование](abstract.md#Наследование)
+ [Generics](abstract.md#Generics)
+ [Классы внутри классов](abstract.md#Классы-внутри-классов)
+ [Enum](abstract.md#Enum)
+ [Аннотации](abstract.md#Аннотации)
+ [Java 8 features](abstract.md#Java-8-features)
+ [String](abstract.md#String)
+ [Collections](abstract.md#Collections)
+ [Thread group](abstract.md#Thread-group)
---
+ [Thread](abstract.md#Thread)
---
+ [Интерфейсы](abstract.md#Интерфейсы)
+ [Лямбды](abstract.md#Лямбды)

[hateoas]:img/hateoas.png

[к оглавлению](#Abstract)

## Быстрый старт

- Пустая строка в конце класса - хороший тон
- Лексический анализ - разбивка кода на лексемы (конструкции языка). Просто проверка слов
- Синтаксический анализ - проверка того что набор слов (лексема) что-то значит. 
Порядок слов, точки с запятой
- Семантический анализ - проверка смысла программы. Инициализация локальных переменных, 
наследование методов
- javac - компилятор. `*.java` - нескомпилированный файл. `*.class` - скомпилированный байткод файл
- в директории `src` лежат исходники. `out` - байткод
- импорт пакетов через звёздочку не позволяет понять где точно лежит класс, 
поэтому лучше использовать полный импорт
- `int` занимает 4 байта
- `header` 32 разрядной - 8 байт, у 64 разрядной - 12 байт
- `padding` выравнивание объёма до кратной 8.
- `reference` 32 разрядной - 4 байт, у 64 разрядной - 8 байт
- `array` заголовок + 4 байта на длину массива 
- `Java` статически типизированный язык - он знает какие методы и поля есть у классов заранее

[к оглавлению](#Abstract)

## Примитивы

- Значения по умолчанию не применимы к локальным переменным - потому что байткод,
который будет создан, работает со стеком и выходит локальная переменная, 
без значения ничего не кладёт на стек, а он тупой и всё сломается.
- Типы переменных - локальная, статическая и динамическая
- У `short` есть отрицательные значения, а у `char` нет, и хотя они оба занимают 2 байта информации - 
безопасно преобразовывать их друг к другу нельзя
- Если пользуешься дробными числами лучше использовать `double` из-за большей точности
- Все результаты операций преобразуются в `int` потому что на стек машина использует `int`
- Слишком большое дробное число при приведении к целому преобразется в 
`Integer.MAX_VALUE` или `Integer.MIN_VALUE`
- Слишком большой `double` при попытке преобразования во `float` превращается в бесконечность
- Классы оболочки для примитивов являются иммутабельными
- Передача в методы по значению

[к оглавлению](#Abstract)

## Операторы

- Оператор не `~` просто инвертирует число в битовом отображении. 
Чтобы получить отрицательное число целого положительного нужно его инвертировать и -1
- `FPU - floating point unit` сопроцессор для работы с числами с плавающей точкой. 
В разных процессорах результат может быть немного разный. Для этого есть ключевое слово `strictfp`

[к оглавлению](#Abstract)

## Клонирование

- Наследовать интерфейс Cloneable
- Deep and  Shallow clone
- Конструктор клонирования если есть `final` поля
- Клонирование через `super.clone()` не вызывает конструктора

[к оглавлению](#Abstract)

## Наследование

- Приватные поля тоже наследуются неявно. 
Потому что может использовать публичные сеттеры родителя.
- Наследование лучше не использовать, если наследник не является базовым классом. 
Принцип Барбары Лисков (`SOLID`). 
Например, не всегда можно заменить Прямоугольник дочерним классом Квадрат.
- порядок запуска блоков инициализации и конструкторов
- Позднее связывание (`dynamic binding`), когда мы вызываем переопределённый метод у наследника, 
а вызов статических методов - ранее связывание (`static binding`).
- аннотации могут быть анализированы компилятором, java agent, код
- при запуске компилятор поднимается в класс и ищет метод, если его нет, то идёт в родителя.
работает и для статических методов, хотя их нельзя переопределять. 
- Статические методы рекомендуется вызывать по имени класса, а не по ссылке, 
из-за shadowing (перекрытия) - для наследников статический метод класса скрывает 
одноименные статические методы с той же сигнатурой родительского класса.
- Чтобы вызвать метод дочернего класса из ссылки 
родительского класса необходимо будет сделать `Class cast`
- Статические методы нельзя переопределять нестатическими и наоборот
- Метод подстановки (опять Лисков) мы можем сузить тип возвращаемого 
значения в методе наследнике при переопределении
- для примитивных типов `Arrays.sort()` использует `QuickSort` (нестабильная сортировка), 
для ссылочных `TimSort` (стабильная сортировка)
- Стабильная сортировка это когда элементы сортируемого массива не меняют относительный порядок.
н-р при сортировке по чиловому ключу 
`{1, A} {3, B} {2, C} {2, A}` -> `{1, A} {2, C} {2, A} {3, B}`, 
а не в `{1, A} {2, A} {2, C} {3, B}`
- Ромбовидное наследование, которого нет в Java состоит из наследования состояния (поля)
и дублирование поведения (методы).

[к оглавлению](#Abstract)

## Generics

- Когда он нужен? Когад у вас есть общая функциональность, 
но в некоторых случаях она может отличаться от типа к типу. Либо вы хотите более типобезопасно работать.
То есть при начальной инициализации работать только с определённым типом.
- Внутри класса для дженериков можно использовать только методы класса `Object`, 
если нет ограничений
- Нужен для того, чтобы переложить ответственность за код с разработчика на компилятор. 
Так как дженерики позволяют ограничить применение каких-то типов и их методов, 
когда заранее неизвестно какой тип будет использоваться.
- c 7 версии при объявлении дженериков в создаваемом объекте можно использовать `<>` 
diamond systax, а в ссылке обязательно указывать конкретные, а не фиктивные типы вместо дженериков
- row generic - сырой дженерик, когда в параметризированный класс не определяется никакой тип в `<>`,
и автоматически туда подставляется тип `Object`
- Дженерики инвариантны, а массивы ковариантны. Первое, 
потому что дженерики не сохраняются отношение наследования, а массивы сохраняют
- Если мы используем сырой тип, то он может сломать работу дженерика, 
потому что они перетирают логику дженериков и делают эти объекты ковариантными
- стирание типов (Type erasing) - компилятор в ходе компиляции вычищает все дженерики 
и заменяет их `Object` либо в зависимости от ограничений дженерика. 
Это нужно для обратной совместимости языка
- Ссылки дженерика `<?> `нужны когда нам не важно что там лежит
- PECS -  в ссылки `<? extends Number>` нельзя ничего класть, но можно получать, а в ссылки типа 
`<? super Cat>` мы можем класть наследников `Cat`, но не может=м ничего получить.
**Producer Extends Consumer Super**
- параметризованные методы - если класс не использует дженерики, 
либо использует другие типы дженериков, то параметрезованные методы позволяют создать 
что-то типа своего контекста для этих дженериков в рамках этого метода.
- Нельзя создавать дженерик объекты - компилятор не знает объект какого типа 
нужно будет создавать и сколько места резервировать для объекта
- Параметризованные поля не могут быть статическими - 
потому что все объекты могут иметь доступ к статическому полю и не знают чего там ожидать.
- Нельзя параметризовать наследников `Throwable`, ENUM, анонимные классы. 
Потому что будет непонятно в какой catch блок отлавливать параметризованную ошибку после стирания типов. 
н-р `Comparable<Person>`.
Потому что ENUM создаются сразу после компиляции программы строго определённых типов.
Потому что экземпляр анонимного класса только один.

- `Ковариантность возвращаемого значения` это про полиморфизм, когда мы сужаем тип возвращаемого значения в потомке
- Все локальные переменные и все незафиксированные переменные-дженерики - стираются в левую границу. 
- Если есть какая-то метаинформация. н-р Статические поля-дженерики или определённые при наследовании дженерики, 
возвращаемые значения - то эта информация в рантайме сохранится и можно её вытащить.
- `Bridge method` методы генерируемые JVM для перенаправления метода с типом `Object` в метод с дженериком.
- `CheckedList` нужны как раз для борьбы с использованием сырых дженериков. Они запоминают класс тип, 
который хранит эта коллекция, для дальнейшей проверки.
- Если метод использует дженерики, то ссылка может заказывать тип дженерика. В примере ниже -
в метод `getList()` вместо `T` заказывается `Number`
```java
public class Example {
    @Test
    void test(){
        Number list = getList(); // Number list = Example<Number>.getList();
    } 
    
    private static <T extends List<String>> T getList(){
        return (T) new ArrayList<String>();
    }
}
```

[к оглавлению](#Abstract)

## Классы внутри классов

- `Nested` (вложенные) классы - статический класс внутри оборачивающего 
класса без привязки к стейту внешнего класса. 
Нет доступа к нестатическим полям оборачивающего класса
- `Inner` (внутренний) класс - нестатический класс внутри класса. 
Неявно хранит ссылку на объект оборачивающего класса. Объект не разразрывно связан с тем, 
что есть вокруг.
- Внешний и внутренний классы не обращают на модификаторы `private` друг друга
- `ConcurrentModificationException` может возникнуть в однопоточной среде, например, 
если мы создали итератор, потом сразу же очистили коллекцию, итератор не может быть уверен, 
что над его клиентов не проводили операции и может выбросить эту ошибку
- `fail-fast` это способность рано выбросить ошибку при возникновении затруднений
- nested весят меньше из-за отсутствия неявной ссылки на внешний объект. 
То есть если нет необходимости связывать обёртку и подсаженный класс, то используется nested
- Inner классы не могут содержать статических полей, кроме констант вычисляемых на этапе компиляции
- Подсаженные классы могут иметь наследников
- Подсаженные классы бывают локальные - 
объявляются внутри метода и только внутри него могут использоваться.
- Локальные классы не имеют области видимости и не могут использоваться выше строки его объявления
- Если наследник подсаженного класса находится в другом файле (другой области видимости), 
то он теряет доступ к полям вложенного для родителя класса
- подсаженные классы внутри интерфейсов всегда `Nested` (статические)
- анонимные классы это `Inner` классы, потому что имеют доступ к нестатическим полям родителя
- у анонимных классов нет дженериков и конструкторов


[к оглавлению](#Abstract)

## Enum

- Нужны для создания заданного ограниченного списка констант объектов, 
которые позволяют жестко ограничить возможные значения
- энам не могут иметь наследников
- наследуются все от `java.lang.Enum` и `java.lang.Comparable`
- могут реализовывать интерфейсы, но не могут быть абстрактными
- и их нельзя создавать
- они все public static final


[к оглавлению](#Abstract)

## Аннотации
- нужны как информация для компилятора(`@FunctionalInterface` не даст скомпилировать, 
если у интерфейса не 1 неопределённый интерфейс), 
для компиляции кода, обработка в рантайме
- джарник это архив 
- папку out можно запаковать в zip дать ей расширение jar и всё
- `@Target` - к чему эта аннотация может применяться
- `@Documented`  - аннотация применяется в javaDoc
- `@Retention` - кому доступна эта аннотация -  SOURCE, CLASS, RUNTIME
- рефлексия это апи, позволяющее в рантайме обратиться к JVM и получить метаинформацию.
Позволяет получить даже приватные методы и изменять финализированные поля.
- `@Deprecated`, `@Override`, `@SuppressWarnings` - стандартные аннотации
- Ломбок. Когда запускаем javac - он анализирует код (лексический, синтаксический, семантичекий)
и строит `AST(abstract syntax tree)` дерево. Если над каким то узлом висит аннотация, он смотрит, 
а есть ли процессор аннотаций, который отвечает за эту аннотацию? Если препроцессор нашелся, 
то компилятор отдаёт ему это дерево и он изменяет, добавляет, перестраивает это дерево.


[к оглавлению](#Abstract)

## Java 8 features

- Если класс наследует два интерфейса у которых есть методы с одинаковой сигнатурой - 
то это не нарушает контракт и компилятор ругаться не будет.
- Если класс реализует два интерфейса у которых есть дефолтные методы с одинаковой сигнатурой - 
то если мы переопределяем этот метод, то всё нормально, если не переопределяем, 
то компилятор ругнётся
- `@FunctionalInterface` это интерфейс с одним абстрактным методом, 
который не зависит от состояния реализующего объекта (`stateless`)
- Чистый метод - stateless, не зависит от состояния объекта, он принимает аргументы, 
совершает операцию и возвращает результат
- `@FunctionalInterface` компилятор проверяет, если в этот интерфейс добавить 
еще один абстрактный метод, то он ругнётся. И этот интерфейс точно можно использовать в лямбде
- лямбда это просто анонимная функция
- лямбды не создают отдельного класс файла. В момент обращения jvm его скомпилирует и загрузит.
- ссылки на методы бывают трёх типов - ссылка на статический и нестатический метод и на конструктор

[к оглавлению](#Abstract)

## String

- На брейкпоинтах происходит `stop-the-world`
- Alt+F8 evaluate запуск своего кода на брейкпоинте
- прямая рекурсия - когда метод вызывает сам себя может привести в `StackOverflowException`
- хвостовая рекурсия - когда вызов метода самого себя стоит в конце метода
- опосредованная, когда есть два метода поочередно вызывающие себя
- Сортировка слиянием (Merge Sort) - рекурсивно делим массив на пары элементов, 
а потом поднимаясь вверх сливаем мелкие массивы в более большие
- Кодировка состоит из 1) это таблица в которой записан символ и соответствующее ему 
число 2) последовательность бит, которое будет представлять символ
- `CharSequence` - базовый интерфейс для `String`, `StringBuilder`, `StringBuffer`
- метод `charAt` может выдать неправильный результат, 
если символ является составным из расширенной таблицы, лучше использовать `codePointAt`
- `intern()` jvm пробегает по пулу строк и возвращает ссылку на объект из пула строк, 
либо помещает его в пул строк
- неразрывный пробел для `trim()` не является пробельным символом. Alt + 2 5 5
- `StringBuilder` and `StringBuffer` не переопределяют методы `equals()` и `hashCode()`
- дефолтная ёмкость `StringBuilder` = 16 символов + длина начальнйо строки
- паттерн Строитель нужен для борьбы с телескопическими конструкторами и fail-fast поведения
- Строковое представление null = "null"
- `+` переопределен только для строк
- в `printf` индексация с нуля
- интернирование происходит во время компиляции
- До 7 java пул строк был в пермгене, а значит его можно было заполнить, сделать Memory Leak. 
С 7 версии пул строк находится в куче и подвергается проверке сборщиком мусора
- Дедупликация вместо интернирования. Делает по факту то же самое что и интернирование, 
но необходимо включить специальные флаги для JVM и подключить G1 GC.

[к оглавлению](#Abstract)

## Collections

[к оглавлению](#Abstract)

## Thread group

- Сейчас TreadGroup используются только для группировки потоков:
  - общее имя, отслеживания количества живых потоков и отправки им сигнала на остановку.
  - назначение общего `ExceptionHandler`
- Поток вызывающий метод `join()` у другого потока ставится на паузу. 
Но если вызвать `join(500)` (с временем) может вызвать неожиданную 
проблему - неясно ожидание завершилось по причине завершения 
присоединённого потока или из-за ошибки в нём
- Методы `getName()`, `getMaxPriority()`, `getParent()`, `activeCount()`, 
`activeGroupCount()`
- `destroy()` лучше вызывать у групп с законченными потоками, 
чтобы освободить ссылки на сами потоки. Также нельзя добавлять новые потоки в 
группу после использования этого метода. Можно вызвать метод `destroy()` автоматически,
если пометить группу как демон `setDaemon(true)`.
- Потоки из разных групп не могут друг на друга действовать, например, вызвать метод
`interrupt()` из потока группы А в поток группы Б. Для этого есть метод `checkAccess()`,
который проверяет настройки `SecurityManager` на наличие прав, но `SecurityManager` в 
современных приложениях почти не используется.

[к оглавлению](#Abstract)

## Thread

### Потоки демоны
- Создаваемый новый поток наследует от родителя только группу.
- Приложение работает до тех пор, пока есть хотя бы один живой не-демон поток.
- Потоки-демоны не влияют на длительность жизни приложения (работы JVM). 
Из-за этого в потоки-демоны нельзя помещать логику изменяющую состояние, н-р запись в файл.
Так же даже логика в блоке `finally` может не выполниться. Во всё остальном это обычные потоки.
- Потоки-демоны используются н-р в логировании. Это сервисные потоки.

### interrupt()
- `interrupt()` руководствуется механизмом ***Коллективной ответственности*** - 
то есть не только поток вызвавший метод решает что другой поток надо прервать, 
но и прерываемый поток тоже должен подтвердить, что он готов прерваться.
- `isInterrupted()` - проверяет значение "флажка" (прервал ли кто меня), 
а `interrupted()` после вызова скидывает флажок обратно.

### volatile

- `atomacity` Помогает только для атомарного чтения и записи 
- `visibility` Гарантирует актуальность значения
- вешается на поля, чтобы значение поля не кешировалось в цп.
- `volatile` не спасает от `race condition`
- `критическая секция` - позволяет выполнять блок атомарно
- Чтение и запись атомарность гарантируется для примитивов кроме `long` и `double`. 
- Чтение и запись ссылочных тоже атомарна

### synchronized

- у каждого объекта в хипе в заголовке есть монитор. 2 бита на хранение монитора. 
Один бит - просто захват, а второй - **biased**. Также в заголовке указан идентификатор потока, 
захватившего монитор
- **race condition** - случай когда в критическую секцию одновременно заходят два или 
более потоков и от порядка операций будет зависеть результат. 
Чтобы этого избежать необходимо использовать мониторы.
- перед блоком либо перед методом
- приоритет потока не влияет на приоритет выдачи монитора объекта. 
В каком порядке потоки пришли к монитору не играет роли - зависит от реализации JVM.
- **starvation** - ситуация, когда поток раз за разом проигрывает розыгрыш на ресурс
  - вход в монитор
  - квант времени процессов
  - воркерам
  - по памяти
- Если какая-то операция может вызвать `InterruptedException`, но к тому момент флажок 
`isInterrupted` уже проставлен, то ошибка будет вызвана до того как JVM приступит к этой операции
- При сравнении примитива и враппера - враппер разворачивается и сравниваются два примитива.
- Не стоит синхронизироваться на врапперах. 
Потому что каждый раз будет происходить захват мониторов разных объектов. 
И еще врапперы будут шариться по всему приложению и может произойти 
синхронизация разных частей приложения по одному врапперу.
- несинхронизованные блоки могут работать одновременно с синхронизованными, 
потому что несинхронизованные методы даже не смотрят на монитор объекта 
и не проверяют его занятость.
- методы с `synchronized` согласно поведению happens-before всегда возвращают 
в память актуальные значения переменных, но несинхронизованные методы 
могут видеть неактуальные данные и поэтому при работе одновременно синхронизованных 
и несинхронизованных методов необходимо использоваться для переменных ключевое слово `volatile`.
- Чтение и запись в `volatile` перемнные дешевле чем вхо и выход в блоки `synchronized`
- Вместо объектов с `synchronized` методов в качестве мониторов
лучше использовать приватные объекты мониторы. 
Потому что сторонний метод так же может использовать монитор вашего объекта.
Тогда внутри этого объекта лучше создать приватный лок-объект и на нём синхронизироваться.
Хотя вместо приватного синхронизационного объекта можно использовать аннотации Ломбока.
- Так же синхронизированные методы могут быть переопределены в 
наследниках класса как несинхронизованные, что может вызвать проблемы. 
- абстрактные Synchronized методы и Synchronized методы в интерфейсах запрещены потому что 
ключевое слово Synchronized ни к чему не обязывает 

[к оглавлению](#Abstract)


## Интерфейсы

### Методы по умолчанию

- Методы по умолчанию предназначены для расширения существующих интерфейсов новыми возможностями
  - Методы по умолчанию позволяют избежать создания служебных классов. 
  Все необходимые методы могут быть представлены в самих интерфейсах.
  - Методы по умолчанию дают свободу классам выбрать методы, которые нужно переопределить.
  - Методы по умолчанию не могут переопределить методы класса `Object`
  - Методы по умолчанию низший приоритет при переопределении
- Если ниже по иерархии (в наследниках) есть абстрактный метод с данной сигнатурой, 
то насоедники будут требовать реализацию, несмотря на наличие дефолтного метода
- Видимо при наследовании идёт рекурсивный поиск реализации абстрактных методов по всем ветвям. 
И даже если в одной ветке до самой глубины этот метод не определён, а по другой ветке определён, 
то JVM этого хватает.
- Планировалось, что методы по умолчанию это способ добавления новых методов 
с поддержанием обратной совместимости. Могут возникнуть проблемы, 
когда у родителей появилось независимо два метода с одинаковой сигнатуро - 
компилятор не будет знать что какую реализацию выбрать. 
В таком случае лучше никогда не наследоваться от двух библиотечных родителей, 
а создать два независимых потомка и агрегировать их как-то.
---

### Binary compatibility
- `binary compatibility` - бинарная совместимость - какие изменения вы можете вносить в ваш байткод 
без необходимости перекомпиляции.
  - Изменение реализации существующих методов, конструкторов, блоков инициализации
  - Добавление новых полей, методов, конструкторов в интерфейсам и классам
  - Удаление приватных полей, методов, контрукторов класса
  - Перемещенеи методов наверх по иерархии класса
  - Добавление новых классов и интерфейсов

[к оглавлению](#Abstract)

## Лямбды

[к оглавлению](#Abstract)

[Заглавная](README.md)
