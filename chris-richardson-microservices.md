[Заглавная](README.md)

# Chris Richardson Microservices

+ [3.Межпроцессное взаимодействие](chris-richardson-microservices.md#Межпроцессное-взаимодействие)
+ [4.Шаблон Сага](chris-richardson-microservices.md#Шаблон-Сага)
+ [5.Проектирование бизнес-логики в микросервисной архитектуре](chris-richardson-microservices.md#Проектирование-бизнес-логики-в-микросервисной-архитектуре)

[restoring-after-fail]:img/books/chris-richardson/restoring-after-fail.jpg
[pattern-remote-procedure-call]:img/books/chris-richardson/template-rpc.jpg
[async-messaging]:img/books/chris-richardson/async-messaging.png
[selfrgistration-clientsidedetection]:img/books/chris-richardson/selfrgistration-clientsidedetection.jpg
[sideregistration-serversidedetection]:img/books/chris-richardson/sideregistration-serversidedetection.jpg
[async-point-point]:img/books/chris-richardson/async-point-point.png
[async-messaging-api]:img/books/chris-richardson/async-messaging-api.png
[duplicated-rejecting]:img/books/chris-richardson/duplicated-rejecting.png
[data-replica]:img/books/chris-richardson/data-replica.png
[saga]:img/books/chris-richardson/saga.png
[choriography]:img/books/chris-richardson/choriography.png
[orchestration]:img/books/chris-richardson/orchestration.png
[saga-types]:img/books/chris-richardson/saga-types.png
[domain-model]:img/books/chris-richardson/domain-model.png
[transaction-scenario]:img/books/chris-richardson/transaction-scenario.png

[к оглавлению](#Chris-Richardson-Microservices)

## Межпроцессное взаимодействие

#### Шаблон удалённый вызов процедур
![icon][pattern-remote-procedure-call]

#### Восстановление после отказа
![icon][restoring-after-fail]

#### Обнаружение сервисов
- Саморегистрация и обнаружение на клиентской стороне
![icon][selfrgistration-clientsidedetection]

- Сторонняя регистрация и обнаружение на стороне сервера
![icon][sideregistration-serversidedetection]

#### Асинхронное взаимодействие

---
Виды сообщений
- Документ - просто данные
- Команда - равна запросу в рест
- Событие
Второе и третье используется в микрсоервисах
---
Виды каналов сообщений в ассинхронном обмене сообщений.
- Точка-точка - равно запросу. 1к1. Для команд
- Издатель - подписчик. 1toN. Для событий
---
![icon][async-messaging]

Двунаправленные сообщения точка-точка
![icon][async-point-point]

Асинхронный API состоит из операций, вызываемых клиентами, и событий, кото­ рые публикуют сервисы. 
Эти два аспекта документируются по-разному.

![icon][async-messaging-api]

- API в стиле «запрос/асиюсронный ответ» — состоит из канала команд сервиса,
типов и форматов командных сообщений, которые сервис принимает, 
а также типов и форматов ответных сообщений, отправляемых сервисом.
- API в стиле однонаправленных уведомлений — состоит из канала команд сервиса, 
а также типов и форматов командных сообщений, которые принимает сервис.
---
Приложения, основанные на сообщениях, обычно применяют брокер сообщений — 
инфраструктурный компонент, через который сервисы общаются друг с другом.
Архитектура обмена сообщениями может и не иметь брокера, 
в этом случае сервисы взаимодействуют между собой напрямую. 
У них есть разные достоинства и недостатки, 
но обычно решения с участием брокера оказываются более удачными.
---
При выборе брокера сообщений следует учитывать различные факторы, включая следующие.
- Поддерживаемые языки программирования. 
Лучше выбрать брокер с поддержкой широкого диапазона языков программирования.
- Поддерживаемые стандарты обмена сообщениями. 
Поддерживает ли брокер сообщений стандарт вроде AMQP или STOMP? 
Использует ли он свой закрытый протокол?
- Порядок следования сообщений. Сохраняет ли брокер порядок следования сообщений?
- Гарантии доставки. Какие гарантии доставки дает брокер сообщений?
- Постоянное хранение. Сохраняются ли сообщения на диск? Могут ли они пережить сбой брокера?
- Устойчивость. Если потребитель переподключится к брокеру, 
получит ли он сообщения, отправленные, пока он был отключен?
- Масштабируемость. Насколько масштабируем брокер сообщений?
- Латентность. Какова сквозная латентность?
- Конкурирующие потребители. Поддерживает ли брокер сообщений конкурирующих потребителей?
---
Существует несколько методов работы с повторяющимися сообщениями:
- `добавление в сообщения идемпотентных дескрипторов`
Если программная логика, обрабатывающая сообщения, является идемпотентной, 
дубликаты не несут в себе никакой опасности. Логика считается идемпотентной, 
если ее многократное выполнение с идентичными входными значениями не имеет 
дополнительных эффектов. 
Например, отмена уже отмененного заказа — это идемпотентная операция.
- `отслеживание и отклонение дубликатов`
В качестве простого решения можно сделать так, чтобы потребитель отслеживал 
обработанные сообщения с помощью идентификаторов и отклонял любые дубликаты. 
Например, он может сохранять в базе данных идентификатор каждого сообщения, 
которое обработал.

![icon][duplicated-rejecting]

---
`Шаблон - Публикация событий`
Сообщения могут временно храниться в специальной таблице бд на стороне отправителя, 
для сохранения историчности в случае отказа потребителя.
`Шаблон - Опрашивающий издатель`
Публикует события в брокер считывая данные из специальной таблицы издателя
`Шаблон - Отслеживание транзакционного журнала`
Читает транзакционный журнал бд и публикует изменения в брокер
(Debezium, LinkedIn Databus, DynamoDB streams, Eventuate Tram )
---
Существует несколько способов уменьшения объема синхронного взаимодействия 
с другими сервисами при обработке синхронных запросов. 
Во-первых, чтобы полностью избежать этой проблемы, все сервисы можно снабдить 
исключительно асинхронными API. Но это не всегда возможно. Например, 
публичные API обычно придерживаются стандарта REST. 
Поэтому некоторые сервисы обязаны иметь синхронные API.
---
Повышение независимости сервисов достигается путём создания в 
сервисах локальной копии необходимых данных.
В некоторых случаях репликация данных — это хорошее решение. 
Например, как сервис Order реплицирует данные сервиса Restaurant, 
чтобы иметь возможность проверять элементы меню. Один из недостатков этого подхода 
связан с тем, что иногда он требует копирования больших объемов данных, что неэффективно. 
Например, если у нас много заказчиков, хранить реплику данных, принадлежащих сервису 
Consumer, может оказаться непрактично. Еще один недостаток репликации кроется в том, 
что она не решает проблему обновления данных, принадлежащих другим сервисам.

![icon][data-replica]

[к оглавлению](#Chris-Richardson-Microservices)

## Шаблон Сага

![icon][saga]

Повествование отличается от простых ACID транзакций отсутствием "I" - изолированности.
В случае отката или ошибки одной из транзакций в саге - 
включаются компенсационные транзакции в обратном порядке.
---
Координирующую логику можно структурировать следующими способами - Хореография и Оркестрация

---

#### Хореография
распределение принятия решений и упорядочения действий между 
участниками повествования, которые в основном общаются, обмениваясь событиями.

![icon][choriography]

1) Необходимо использовать ассинхронный обмен сообщениями. 
2) Наличие сквозного `идентификатора соответствия` 
общего для транзакций в разных микросервисах

Плюсы:
- Простота
- Слабая связанность

Минусы:
- Сложность для понимания. Логика разбросана по сервисам
- Наличие циклических зависимостей между сервисами. Может быть проблемой, но не всегда
- Риск жесткого связывания. Если логика изменится, то придётся много где изменять.

---

#### Оркестрация

централизация координирующей логики повествования в виде
класса-оркестратора. Оркестратор отправляет участникам повествования командные сообщения
с инструкциями, какие операции нужно выполнить.

![icon][orchestration]

Плюсы:
- Упрощение зависимостей. Отсутствие циклических зависимостей
- Меньше связывания.
- Улучшенное разделение ответственности и упрощенная бизнес-логика.

Минусы:
- Риск избыточной централизации бизнес-логики в оркестраторе.

---
#### Аномалии

- Потеря обновлений
- «Грязное» чтение
- Нечеткое/неповторяемое чтение

Как с ними бороться?

- **Семантическая блокировка** — блокировка на уровне приложения.
При использовании семантической блокировки компенсируемая транзакция устанавливает 
флаг во всех записях, которые она создает или обновляет. Н-р статус `*_PENDING`
- **Коммутативные обновления** — проектирование операций обновления таким образом, 
чтобы их можно было выполнить в любом порядке.
- **Пессимистическое представление** — перестановка этапов повествования для минимизации 
бизнес-рисков. Оно меняет местами этапы повествования, чтобы минимизировать бизнес-риски, 
связанные с «грязным» чтением.
- **Повторное чтение значения** — предотвращение «грязного» чтения путем повторного 
считывания данных. Это позволяет убедиться в их неизменности перед тем, 
как их перезаписывать.
- **Файл версий** — ведение записей об обновлениях, чтобы их можно было менять местами.
- **По значению** — использование бизнес-рисков каждого запроса для динамического выбора 
механизма конкурентности. Запросы с низким уровнем риска выполняются в виде повествований и,
возможно, с помощью контрмер, описанных в предыдущем разделе. 
По запросы с повышенным риском (например, связанные с большими суммами денег) 
задействуют распределенные транзакции. Благодаря этой стратегии приложение может 
динамически искать баланс между бизнес-ри- сками, доступностью и масштабируемостью.

---
#### Типы транзакций в саге

![icon][saga-types]

[к оглавлению](#Chris-Richardson-Microservices)

##  Проектирование бизнес логики в микросервисной архитектуре

Для обеспечения согласованности данных между сервисами следует использовать шаблон 
`Повествование`.
К счастью, для преодоления этих трудностей можно воспользоваться шаблоном «Агрегат» 
из состава DDD. `Он структурирует бизнес-логику приложения в виде набора агрегатов.` 
`Агрегат` — это кластер объектов, с которыми можно обращаться как с единым целым.

- Агрегаты исключают любую возможность того, что ссылки на объекты могут выйти за 
рамки одного сервиса, потому что межагрегатная ссылка — это скорее значение 
первичного ключа, а не объектная ссылка.
- Транзакция может создать или обновить лишь один агрегат, поэтому агрегаты 
соответствуют ограничениям транзакционной модели микросервисов.

### Шаблоны организации бизнес-логики

Существует два основных шаблона для организации бизнес-логики: 
- процедурный «Сценарий транзакции» (для простых приложений)
- объектно-ориентированный «Доменная модель».

#### Проектирование бизнес-логики с помощью шаблона «Сценарий транзакции»

Организация бизнес-логики в виде сценариев транзакции. В такой архитектуре один набор 
классов обычно реализует поведение, а другой хранит состояние. `Сценарии транзакции 
организованы в виде классов, у которых нет состояния.` Они применяют классы данных, 
которые, как правило, не обладают поведением

![icon][transaction-scenario]

При использовании этого шаблона `сценарии обычно размещаются в классе сервиса` 
(в данном случае OrderService). Класс сервиса имеет по одному методу для каждого 
запроса или системной операции. Метод реализует бизнес-логику для определенного запроса. 
Он обращается к БД с помощью объектов доступа к данным (data access object, DAO), 
таких как OrderDao.

Вы можете писать код без тщательного продумывания организации классов. Но проблема в том, 
что при довольно значительном усложнении бизнес-логики поддержка вашего кода превратится 
в сплошной кошмар.

#### Проектирование бизнес-логики с помощью шаблона «Доменная модель»

В объектно-ориентированном проектировании бизнес-логика состоит из объектной модели — 
сети относительно небольших классов. Эти классы обычно напрямую соотносятся с концепциями 
из проблемной области.

![icon][domain-model]

Вместо одного большого класса, который берет на себя все функции, `сервис состоит из 
нескольких мелких классов, у каждого из которых есть свой небольшой набор обязанностей`. 
Кроме того, такие классы, как `Account`, `BankingTransaction` и `Overdraftpolicy`, довольно 
точно отражают реальный мир, благодаря чему их роль в архитектуре проще понять.

[к оглавлению](#Chris-Richardson-Microservices)

[Заглавная](README.md)
