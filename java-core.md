[Заглавная](README.md)

# Java Core
+ [Ранее и позднее связывание](java-stream.md#Ранее-и-позднее-связывание)
+ [Отличие лямбды от анонимного класса](java-stream.md#Отличие-лямбды-от-анонимного-класса)
+ [Expression lambda and Statement lambda](java-stream.md#Expression-lambda-and-Statement-lambda)
+ [Мьютекс, монитор и семафор](java-stream.md#Мьютекс,-монитор-и-семафор)
+ [Стирание типов (type erasure)](java-stream.md#Стирание-типов-(type-erasure))
+ [equals and hashcode](java-stream.md#equals-and-hashcode)
+ [fail-fast и fail-safe итераторы](java-stream.md#fail-fast-и-fail-safe-итераторы)
+ [Throwable](java-stream.md#Throwable)
+ [Double checked locking](java-stream.md#Double-checked-locking)
+ [happens before](java-stream.md#happens-before)
+ [Differance IO и NIO](java-stream.md#Differance-IO-и-NIO)

[semaphore]:img/semaphore.PNG
[throwable]:img/throwable.png
[happens-before]:img/happens-before.png
[io-nio-stream-in]:img/io-nio-stream-in.gif
[io-nio-stream-out]:img/io-nio-stream-out.gif

[к оглавлению](#Java-Core)

## Ранее и позднее связывание

- Статическое связывание происходит во время компиляции, а динамическое – во время выполнения.
- Поскольку статическое связывание происходит на ранней стадии жизненного цикла программы, 
его называют ранним связыванием. 
Аналогично, динамическое связывание называют также поздним связыванием, поскольку оно происходит позже, 
во время работы программы.
- Статическое связывание используется в языке Java для разрешения перегруженных методов, 
в то время как динамическое связывание используется в языке Java для разрешения переопределенных методов.
- Аналогично, приватные, статические и терминальные методы разрешаются при помощи статического связывания, 
поскольку их нельзя переопределять, а все виртуальные методы разрешаются при помощи динамического связывания.
- В случае статического связывания используются не конкретные объекты, а информация о типе, 
то есть для обнаружения нужного метода используется тип ссылочной переменной. С другой стороны, 
при динамическом связывании для нахождения нужного метода в Java используется конкретный объект.

[к оглавлению](#Java-Core)

## Отличие лямбды от анонимного класса

Каждый раз при вызове метода `getComparator()` при реализации через анонимный класс (1) будет 
создаваться новый объект и создан класс файл XXX$1.class.
При реализации через лямбды (2) будет отдаться один и тот же объект созданный при первом вызове
и класс-файл не будет создан.
```java
public static Comparator<Integer> getComparator(){
    return new Comparator<Integer>(){ // 1
        @Override
        public int compare(Integer o1,Integer o2){
            return Integer.compare(o1,o2);
        }
    };
// ...
    return (Integer o1,Integer o2) -> { // 2
        return Integer.compare(o1,o2);
    };
}
```
- Лямбда выражение определяет ТОЛЬКО интерфейс, не может определять абстрактный класс
- Лямбды применимы только к функциональным интерфейсам. ```Comparable``` и ```Clonable``` не функциональные интерфейсы.
- В лямбдах ```this``` ссылается на внешний класс, а не на определяемый
- Внешние переменные в лямбдах не обязаны быть ```final```, 
они сами дополняются этим маркером при помощи компилятора и в документации называются ```effectively final```
- Лямбды не создают класс файл *(см выше)*

[к оглавлению](#Java-Core)

## Expression lambda and Statement lambda

```java
// Statement lambda (может состоять из нескольких выражений и окружена {})
(Integer o1,Integer o2) -> { return Integer.compare(o1,o2);};

// Expression lambda
(Integer o1,Integer o2) -> Integer.compare(o1,o2);
```
[к оглавлению](#Java-Core)

## Мьютекс, монитор и семафор

- *Мьютекс* — это специальный объект для синхронизации потоков. 
Задача мьютекса — обеспечить такой механизм, чтобы доступ к объекту в определенное время был только у одного потока
1) Возможны только два состояния — «свободен» и «занят». 
2) Состояниями нельзя управлять напрямую. 
В Java нет механизмов, которые позволили бы явно взять объект, получить его мьютекс и присвоить ему нужный статус.

- *Монитор* — это дополнительная «надстройка» над мьютексом, это «невидимый» для программиста кусок кода.

```java
public class Main {
   private Object obj = new Object();
   public void doSomething() {
       synchronized (obj) {
           obj.someImportantMethod();
       }
   }
}
```

Преобразуется в нечто подобное (!!!Псевдокод):
```java
public class Main {

   private Object obj = new Object();

   public void doSomething() throws InterruptedException {
       while (obj.getMutex().isBusy()) {
           Thread.sleep(1);
       }
       obj.getMutex().isBusy() = true;
       obj.someImportantMethod();
       obj.getMutex().isBusy() = false;
   }
}
```

- *Семафор* — это средство для синхронизации доступа к какому-то ресурсу. 
Его особенность заключается в том, что при создании механизма синхронизации он использует счетчик. 
Счетчик указывает нам, сколько потоков одновременно могут получать доступ к общему ресурсу.

![icon][semaphore]

```java
Semaphore(int permits);
Semaphore(int permits, boolean fair);
```

- ```int permits``` — начальное и максимальное значение счетчика. То есть то, 
сколько потоков одновременно могут иметь доступ к общему ресурсу;

- ```boolean fair``` — для установления порядка, в котором потоки будут получать доступ. 
Если fair = true, доступ предоставляется ожидающим потокам в том порядке, в котором они его запрашивали. 
Если же он равен false, порядок будет определять планировщик потоков.

```java
class Philosopher extends Thread {

   private Semaphore sem;
   // поел ли философ
   private boolean full = false;
   private String name;

   Philosopher(Semaphore sem, String name) {
       this.sem=sem;
       this.name=name;
   }

   public void run() {
       try {
           // если философ еще не ел
           if (!full) {
               //Запрашиваем у семафора разрешение на выполнение
               sem.acquire();
               System.out.println (name + " садится за стол");

               // философ ест
               sleep(300);
               full = true;

               System.out.println (name + " поел! Он выходит из-за стола");
               sem.release();

               // философ ушел, освободив место другим
               sleep(300);
           }
       }
       catch(InterruptedException e) {
           System.out.println ("Что-то пошло не так!");
       }
   }
}
```

Код запуска

```java
public class Main {

   public static void main(String[] args) {

       Semaphore sem = new Semaphore(2);
       new Philosopher(sem,"Сократ").start();
       new Philosopher(sem,"Платон").start();
       new Philosopher(sem,"Аристотель").start();
       new Philosopher(sem,"Фалес").start();
       new Philosopher(sem,"Пифагор").start();
   }
}
```

[к оглавлению](#Java-Core)

## Стирание типов (type erasure)

Внутри класса не хранится никакой информации о его типе-параметре при работе с ```generics```.
Эта информация доступна только на этапе компиляции и стирается (становится недоступной) в ```runtime```.

```java
public class TypeErasionSecond<T> {

    private T value1;
    private T value2;

    public void printValues() {
        System.out.println(value1);
        System.out.println(value2);
    }

    public static <T> TypeErasionSecond<T> createAndAdd2Values(Object o1, Object o2) {
        TypeErasionSecond<T> result = new TypeErasionSecond<>();
        result.value1 = (T) o1;
        result.value2 = (T) o2;
        return result;
    }

    public static void main(String[] args) {
        Double d = 22.111;
        String s = "Test String";
        TypeErasionSecond<Integer> test = createAndAdd2Values(d, s);
        test.printValues();
    }
}
```

Или другой пример
```java
public class Main {

   private class Cat {}

   public static void main(String[] args) {
       List<String> strings = new ArrayList<>();
       List<Integer> numbers = new ArrayList<>();
       List<Cat> cats = new ArrayList<>();

       System.out.println(strings.getClass() == numbers.getClass());
       System.out.println(numbers.getClass() == cats.getClass());

   }
}
```

!!! Массивы не подвержены стиранию типов
```java
public class Main2 {
   public static void main(String[] args) {
       Object x[] = new String[3];
       x[0] = new Integer(222); // Exception in thread "main" java.lang.ArrayStoreException: java.lang.Integer
   }
}
```

[к оглавлению](#Java-Core)

## equals and hashcode

### Контракт equals

При переопределении метода equals разработчик должен придерживаться основных правил, 
определенных в спецификации языка Java.
- **Рефлексивность**
для любого заданного значения `x`, выражение `x.equals(x)` должно возвращать `true`.
Заданного — имеется в виду такого, что `x != null`
- **Симметричность**
для любых заданных значений `x` и `y`, `x.equals(y)` должно возвращать `true` только в том случае, 
когда `y.equals(x)` возвращает `true`.
- **Транзитивность**
для любых заданных значений `x`, `y` и `z`, если `x.equals(y)` возвращает `true` и `y.equals(z)` возвращает `true`, 
`x.equals(z)` должно вернуть значение `true`.
- **Согласованность**
для любых заданных значений `x` и `y`повторный вызов `x.equals(y)` будет возвращать значение 
предыдущего вызова этого метода при условии, что поля, используемые для сравнения этих двух объектов, 
не изменялись между вызовами.
- **Сравнение null**
для любого заданного значения `x` вызов `x.equals(null)` должен возвращать `false`.

### Общий алгоритм определения equals
1) Проверить на равенство ссылки объектов `this` и параметра метода `o`.
`if (this == o) return true;`
2) Проверить, определена ли ссылка `o`, т. е. является ли она `null`.
Если в дальнейшем при сравнении типов объектов будет использоваться оператор `instanceof`, 
этот пункт можно пропустить, т. к. этот параметр возвращает `false` в данном случае `null instanceof Object`.
3) Сравнить типы объектов `this` и` o` с помощью оператора `instanceof` или метода `getClass()`, 
руководствуясь описанием выше и собственным чутьем.
4) Если метод `equals` переопределяется в подклассе, не забудьте сделать вызов `super.equals(o)`
5) Выполнить преобразование типа параметра o к требуемому классу.
6) Выполнить сравнение всех значимых полей объектов:
- для примитивных типов (кроме `float` и `double`), используя оператор `==`
- для ссылочных полей необходимо вызвать их метод `equals`
- для массивов можно воспользоваться перебором по циклу, либо методом `Arrays.equals()`
- для типов `float` и `double` необходимо использовать методы сравнения соответствующих оберточных классов 
`Float.compare()` и `Double.compare()`
7) И, наконец, ответить на три вопроса: является ли реализованный метод **симметричным**? **Транзитивным**? 
**Согласованным**? Два других принципа (рефлексивность и определенность), как правило, выполняются автоматически.

### Контракт hashCode
Для реализации хэш-функции в спецификации языка определены следующие правила:
- вызов метода `hashCode` один и более раз над одним и тем же объектом должен возвращать одно и 
то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.
- вызов метода `hashCode` над двумя объектами должен всегда возвращать одно и то же число, 
если эти объекты равны (вызов метода `equals` для этих объектов возвращает `true`).
- вызов метода `hashCode` над двумя неравными между собой объектами должен возвращать разные хэш-значения. 
Хотя это требование и не является обязательным, следует учитывать, 
что его выполнение положительно повлияет на производительность работы хэш-таблиц.

[к оглавлению](#Java-Core)

## fail-fast и fail-safe итераторы

Это не какие-то отдельные типы, а характеристики разных реализаций интерфейса `Iterator`. 
Они определяют, как поведет себя итератор при изменении перебираемой последовательности.

`Fail-fast` – «быстрый» итератор. Когда после его создания коллекция как-либо изменилась, 
он падает с ошибкой без лишних разбирательств. Так работает итератор класса `ArrayList`, 
при изменении он выбрасывает `ConcurrentModificationException`. 
Рекомендуется не основывать логику программы на `fail-fast` отказах, 
и использовать их только как признак ошибки реализации.

`Fail-safe` – «умный» итератор. Обычно плата за отказоустойчивость – возможная неконсистентность данных 
(«слабая консистентность»). Итератор класса `ConcurrentHashMap` работает с копией данных, 
он не выбросит исключение при изменении коллекции, 
но может не увидеть часть свежих изменений. Плата за отсутствие ошибок других `fail-safe` итераторов может отличаться, 
детали всегда можно найти в документации коллекций.

[к оглавлению](#Java-Core)

## Throwable

Базовым классом для всех исключений является класс `Throwable`. 
От него уже наследуются два класса: `Error` и `Exception`. 
Все остальные классы являются производными от этих двух классов.

Класс `Error` описывает внутренние ошибки в исполняющей среде `Java`. 
Программист имеет очень ограниченные возможности для обработки подобных ошибок.

Собственно исключения наследуются от класса `Exception`. 
Среди этих исключений следует выделить класс `RuntimeException`. 
`RuntimeException` является базовым классом для так называемой группы непроверяемых исключений (`unchecked exceptions`) 
- компилятор не проверяет факт обработки таких исключений и их можно не указывать вместе с оператором `throws`
 в объявлении метода. Такие исключения являются следствием ошибок разработчика, например, 
 неверное преобразование типов или выход за пределы массива.

![icon][throwable]

Некоторые из классов непроверяемых исключений:

- `ArithmeticException`: исключение, возникающее при делении на ноль

- `IndexOutOfBoundException`: индекс вне границ массива

- `IllegalArgumentException`: использование неверного аргумента при вызове метода

- `NullPointerException`: использование пустой ссылки

- `NumberFormatException`: ошибка преобразования строки в число

Все остальные классы, образованные от класса `Exception`, называются проверяемыми исключениями (`checked exceptions`).

Некоторые из классов проверяемых исключений:

- `CloneNotSupportedException`: класс, для объекта которого вызывается клонирование, не реализует интерфейс Cloneable

- `InterruptedException`: поток прерван другим потоком

- `ClassNotFoundException`: невозможно найти класс

[к оглавлению](#Java-Core)

## Double checked locking

```java
// Однопоточная версия
class Foo {
    private Helper helper = null;
    public Helper getHelper() {
        if (helper == null)
            helper = new Helper();
        return helper;
    }
    // и остальные члены класса…
}
```
Этот код не будет корректно работать в многопоточной программе. Метод `getHelper()` должен получать блокировку на случай,
 если его вызовут одновременно из двух потоков. Действительно, если поле `helper` ещё не инициализировано, 
 и одновременно два потока вызовут метод `getHelper()`, то оба потока попытаются создать объект, 
 что приведет к созданию лишнего объекта. Эта проблема решается использованием синхронизации, 
 как показано в следующем примере.
 
```java
// Правильная, но "дорогая" по времени выполнения многопоточная версия
class Foo { 
    private Helper helper = null;
    public synchronized Helper getHelper() {
        if (helper == null)
            helper = new Helper();
        return helper;
    }
    // и остальные члены класса…
}
```

Этот код работает, но он вносит дополнительные накладные расходы на синхронизацию. 
Первый вызов `getHelper()` создаст объект, и нужно синхронизировать только те несколько потоков, 
которые будут вызывать `getHelper()` во время инициализации объекта. 
После инициализации синхронизация при вызове `getHelper()` является излишней, 
так как будет производиться только чтение переменной. 
Так как синхронизация может уменьшить производительность в 100 раз и более, 
накладные расходы на блокировку при каждом вызове этого метода кажутся излишними: 
как только инициализация завершена, необходимость в блокировке отпадает. 
Многие программисты попытались оптимизировать этот код следующим образом:

1) Сначала проверяется, инициализирована ли переменная (без получения блокировки). Если она инициализирована, 
её значение возвращается немедленно.
2) Получение блокировки.
3) Повторно проверяется, инициализирована ли переменная, так как вполне возможно, 
что после первой проверки другой поток инициализировал переменную. Если она инициализирована, 
её значение возвращается.
4) В противном случае, переменная инициализируется и возвращается.

```java
// Некорректно работающая (в Symantec JIT и версиях Java 1.4 и ранее) многопоточная версия
// Шаблон "Double-Checked Locking"
class Foo {
    private Helper helper = null;
    public Helper getHelper() {
        if (helper == null) {
            synchronized(this) {
                if (helper == null) {
                    helper = new Helper();
                }
            }
        }
        return helper;
    }
    // и остальные члены класса…
}
```

На интуитивном уровне, этот код кажется корректным. Однако существуют некоторые проблемы 
(в версии `Java 1.4` и ранее и нестандартных реализациях `JRE`), которых, возможно, следует избегать. 
Представим себе, что события в многопоточной программе протекают так:

Поток А замечает, что переменная не инициализирована, затем получает блокировку и начинает инициализацию.
Семантика некоторых языков программирования такова, что потоку А разрешено присвоить разделяемой переменной 
ссылку на объект, который находится в процессе инициализации (что в общем-то вполне однозначно нарушает 
причинно-следственную связь, ведь программист вполне явно просил присваивать переменной ссылку на объект
(то есть — опубликовать ссылку в общий доступ) — в момент после инициализации, а не в момент до инициализации).
Поток Б замечает, что переменная инициализирована (по крайней мере, ему так кажется), 
и возвращает значение переменной без получения блокировки. 
Если поток Б теперь будет использовать переменную до того момента, когда поток А закончит инициализацию, 
поведение программы будет некорректным.
Одна из опасностей использования блокировки с двойной проверкой в `J2SE 1.4` (и более ранних версиях) состоит в том, 
что часто кажется, что программа работает корректно. Во-первых, рассмотренная ситуация будет возникать не очень часто;
 во-вторых, сложно отличить корректную реализацию данного шаблона от такой, которая имеет описанную проблему. 
 В зависимости от компилятора, распределения планировщиком процессорного времени для потоков, 
 а также природы других работающих конкурентных процессов, ошибки, 
 спровоцированные с некорректной реализацией блокировки с двойной проверкой, обычно происходят бессистемно. 
 Воспроизведение таких ошибок обычно затруднено.

Можно решить проблему при использовании `J2SE 5.0`. Новая семантика ключевого слова `volatile` даёт возможность 
корректно обработать запись в переменную в данном случае.

```java
// Работает с новой семантикой volatile
// Не работает в Java 1.4 и более ранних версиях из-за семантики volatile
class Foo {
    private volatile Helper helper = null;
    public Helper getHelper() {
        if (helper == null) {
            synchronized(this) {
                if (helper == null)
                    helper = new Helper();
            }
        }
        return helper;
    }
    // и остальные члены класса…
}
```
[к оглавлению](#Java-Core)

## happens before

«Выполняется прежде» (англ. `happens before`) — отношение строгого частичного порядка 
(арефлексивное, антисимметричное, транзитивное), введённое между атомарными командами 
(++ и -- не атомарны!), придуманное Лесли Лэмпортом и не означающее «физически прежде». 
Оно значит, что вторая команда будет «в курсе» изменений, проведённых первой.

Модель памяти Java

В частности, одно выполняется прежде другого для таких операций (список не исчерпывающий):

Синхронизация и мониторы:
- Захват монитора (начало `synchronized`, метод `lock`) и всё, что после него в том же потоке.
- Возврат монитора (конец `synchronized`, метод `unlock`) и всё, что перед ним в том же потоке.
- Таким образом, оптимизатор может заносить строки в синхроблок, но не наружу.
- Возврат монитора и последующий захват другим потоком.
Запись и чтение:
- Любые зависимости по данным (то есть запись в любую переменную и последующее чтение её же) в одном потоке.
- Всё, что в том же потоке перед записью в volatile-переменную, и сама запись.
- volatile-чтение и всё, что после него в том же потоке.
- Запись в volatile-переменную и последующее считывание её же. Таким образом, 
`volatile`-запись делает с памятью то же, что возврат монитора, а чтение — то же, что захват. 
А значит: если один поток записал в `volatile`-переменную, а второй обнаружил это, всё, 
что предшествует записи, выполняется раньше всего, что идёт после чтения; см. иллюстрацию.
![icon][happens-before]
- Для объектных переменных (например, `volatile List x;`) столь сильные гарантии выполняются для ссылки на объект, 
но не для его содержимого.
Обслуживание объекта:
- Статическая инициализация и любые действия с любыми экземплярами объектов.
- Запись в final-поля в конструкторе и всё, что после конструктора. 
Как исключение из всеобщей транзитивности, это соотношение `happens-before` не соединяется транзитивно 
с другими правилами и поэтому может вызвать межпоточную гонку.
- Любая работа с объектом и `finalize()`.
Обслуживание потока:
- Запуск потока и любой код в потоке.
- Зануление переменных, относящихся к потоку, и любой код в потоке.
- Код в потоке и `join();` код в потоке и `isAlive() == false`.
- `interrupt()` потока и обнаружение факта останова.

[к оглавлению](#Java-Core)

## Differance IO и NIO

- Потокоориентированный и буфер-ориентированный ввод/вывод
- Блокирующий и неблокирующий ввод/вывод
- Селекторы

### Потокоориентированный и буфер-ориентированный ввод/вывод

Основное отличие между двумя подходами к организации ввода/вывода в том, 
что Java IO является потокоориентированным, а Java NIO – буфер-ориентированным. Разберем подробней.
Потокоориентированный ввод/вывод подразумевает чтение/запись из потока/в поток одного или нескольких байт 
в единицу времени поочередно. Данная информация нигде не кэшируются. 
Таким образом, невозможно произвольно двигаться по потоку данных вперед или назад. 
Если вы хотите произвести подобные манипуляции, вам придется сначала кэшировать данные в буфере.

Потокоориентированный ввод:

![icon][io-nio-stream-in]

Потокоориентированный вывод:

![icon][io-nio-stream-out]

Подход, на котором основан Java NIO немного отличается. Данные считываются в буфер для последующей обработки. 
Вы можете двигаться по буферу вперед и назад. Это дает немного больше гибкости при обработке данных. 
В то же время, вам необходимо проверять содержит ли буфер необходимый для корректной обработки объем данных. 
Также необходимо следить, чтобы при чтении данных в буфер вы не уничтожили ещё не обработанные данные, 
находящиеся в буфере.

### Блокирующий и неблокирующий ввод/вывод

Потоки ввода/вывода (`streams`) в Java IO являются блокирующими. Это значит, что когда в потоке выполнения (`thread`) 
вызывается `read()` или `write()` метод любого класса из пакета `java.io.*`, происходит блокировка до тех пор, 
пока данные не будут считаны или записаны. Поток выполнения в данный момент не может делать ничего другого.

Неблокирующий режим Java NIO позволяет запрашивать считанные данные из канала (`channel`) и получать только то, 
что доступно на данный момент, или вообще ничего, если доступных данных пока нет. Вместо того, 
чтобы оставаться заблокированным пока данные не станут доступными для считывания, 
поток выполнения может заняться чем-то другим.

### Каналы (channels)
Каналы – это логические (не физические) порталы, через которые осуществляется ввод/вывод данных, 
а буферы являются источниками или приёмниками этих переданных данных. При организации вывода, данные, 
которые вы хотите отправить, помещаются в буфер, а он передается в канал. При вводе, 
данные из канала помещаются в предоставленный вами буфер.

Каналы напоминают трубопроводы, по которым эффективно транспортируются данные между буферами байтов и сущностями 
по ту сторону каналов. Каналы – это шлюзы, которые позволяют получить доступ к сервисам ввода/вывода операционной 
системы с минимальными накладными расходами, а буферы – внутренние конечные точки этих шлюзов, 
используемые для передачи и приема данных.

Тоже самое справедливо и для неблокирующего вывода. Поток выполнения может запросить запись в канал некоторых данных, 
но не дожидаться при этом пока они не будут полностью записаны.

Таким образом неблокирующий режим `Java NIO` позволяет использовать один поток выполнения для решения 
нескольких задач вместо пустого прожигания времени на ожидание в заблокированном состояний. 
Наиболее частой практикой является использование сэкономленного времени работы потока выполнения 
на обслуживание операций ввода/вывода в другом или других каналах.

[Заглавная](README.md)