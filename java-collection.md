[Заглавная](README.md)

# Java Collection

+ [CopyOnWrite](java-collection.md#CopyOnWrite)
+ [BlockingQueue](java-collection.md#BlockingQueue)

[к оглавлению](#Java-Collection)

##CopyOnWrite

- `CopyOnWriteArrayList` и `CopyOnWriteArraySet` необходимы при наличии 
многих читателей и немногих писателей. При каждом добавлении нового элемента 
создаётся новый внутренний массив с элементами, а после добавления ссылка заменяется.
Это спасает от проблемы гонки в многопоточной среде. Создание нового массива и 
копирование всех значений - очень дорогая операция, поэтому использовать эти 
структуры следует только при большом количестве читателей и нечастых изменениях писателями.

[к оглавлению](#Java-Collection)

## BlockingQueue

| | Throws exception | Special value | Blocks  |
------------------|---------------|---------| ---
| Insert           | add(e) | offer(e) | put(e) | offer(e, time, unit)
| Remove           | remove() | poll() | take() | poll(time, unit)
| Examine          | element() | peek() | not applicable | not applicable

- `ArrayBlockingQueue`
  - Внутри массив на фиксированное количество элементов
  - Может быть честным и нечестным
- `LinkedBlockingQueue` Идеально при равномерном количестве читателей и писателей. 
  Н-р писатели пишут в хвост, а читатели забирают с головы. 
  Но по памяти проигрывает `ArrayBlockingQueue`
- `SynchronousQueue`
  это точка синхронизации, то есть поток отдающий данные просто 
  блокируется до тех пор, пока не придёт другой поток, чтобы забрать данные или наоборот - 
  читатель ждёт писателя.
  - может работать в режиме очереди, а может в режиме стека.
  - Честный\нечестный это очередь\стэк
- `BlockingDeque<T>` и `LinkedBlockingDeque<T> implements BlockingDeque`
  двунаправленная очередь, у которой есть методы для работы и с головой и с хвостом. 
  - Отличается от `LinkedBlockingQueue` тем, что здесь и чтение и запись происходит с обоих сторон. 
  - По производительности так же межденнее чем `LinkedBlockingQueue` на 40%. 
  - Рекомендуется использовать когда необходио реализовывать интерфейс `Deque`
- `LinkedTransferQueue implements TransferQueue<T> extends BlockingQueue<T>` Позволяет 
  узнать ожидает ли кто-нибудь в данный момент с "той стороны трубы". 
Нужен для сохранения атомарности при добавлении многих элементов, чтобы сохранить 
очередь вкладываемых элементов
- `PriorityBlockingQueue` - блокирующая асинхроанная очередь с приоритетом. 
То есть элементы с `Comparator`, либо реализуют `Comparable`
- `DelayedBlockingQueue` элементы реализуют интерфейс `Delayed`, то есть элементы можно 
будет не сразу забрать из очереди, а через некоторое время. Посылки выстраваются в 
зависимости от срочности (delay).

[к оглавлению](#Java-Collection)

[Заглавная](README.md)