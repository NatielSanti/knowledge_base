[Заглавная](README.md)

# Theory
+ [IoC,DI,IoC-контейнер](theory.md#IoC,DI,IoC)
+ [SOLID](theory.md#SOLID)
+ [Code Review Google Principces](theory.md#Code-Review-Google-Principces)
+ [AUTH](theory.md#AUTH)
+ [REST](theory.md#REST)
+ [Richardson Maturity Model](theory.md#Richardson-Maturity-Model)
+ [HATEOAS](theory.md#HATEOAS)
+ [Стратегии ветвения GIT](theory.md#Стратегии-ветвения-GIT)

[solid-s]:img/solid/solid1.png
[solid-o]:img/solid/solid2.png
[solid-l]:img/solid/solid3.png
[solid-i]:img/solid/solid4.png
[solid-d]:img/solid/solid5.png
[auth]:img/auth.png
[auth2]:img/auth2.png
[rmm]:img/RichardsonMaturityModel.png
[hateoas]:img/hateoas.png

[к оглавлению](#Theory)

## IoC,DI,IoC

Взаимосвязь между IoC и DI такая же как между Agile и Scrum, т.е.
- **Inversion of Control (инверсия управления)** — это некий абстрактный принцип, 
набор рекомендаций для написания слабо связанного кода. Суть которого в том, 
что каждый компонент системы должен быть как можно более изолированным от других, 
не полагаясь в своей работе на детали конкретной реализации других компонентов.
- **Dependency Injection (внедрение зависимостей)** — это одна из реализаций этого принципа 
(помимо этого есть еще Factory Method, Service Locator).
- **IoC-контейнер** — это какая-то библиотека, фреймворк, программа, которая позволит вам упростить и автоматизировать 
написание кода с использованием данного подхода на столько, на сколько это возможно.

[к оглавлению](#Theory)

## SOLID

Принципы SOLID

**S – Single Responsibility** (Принцип единственной ответственности)
> Каждый класс должен отвечать только за одну операцию.

![icon][solid-s]

Если класс отвечает за несколько операций сразу, вероятность возникновения багов возрастает – внося изменения, 
касающиеся одной из операций вы, сами того не подозревая, можете затронуть и другие.

- Принцип служит для разделения типов поведения, благодаря которому ошибки, вызванные модификациями в одном поведении, 
не распространялись на прочие, не связанные с ним типы.

**O — Open-Closed** (Принцип открытости-закрытости)

> Классы должны быть открыты для расширения, но закрыты для модификации.

![icon][solid-o]

Когда вы меняете текущее поведение класса, эти изменения сказываются на всех системах, работающих с данным классом. 
Если хотите, чтобы класс выполнял больше операций, то идеальный вариант – не заменять старые на новые, 
а добавлять новые к уже существующим.

- Принцип служит для того, чтобы делать поведение класса более разнообразным, не вмешиваясь в текущие операции, 
которые он выполняет. Благодаря этому вы избегаете ошибок в тех фрагментах кода, где задействован этот класс.

**L — Liskov Substitution** (Принцип подстановки Барбары Лисков)

> Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, 
>могут заменяться объектами типа П без негативных последствий для функциональности программы.

![icon][solid-l]

В случаях, когда класс-потомок не способен выполнять те же действия, что и класс-родитель, 
возникает риск появления ошибок.

Если у вас имеется класс и вы создаете на его базе другой класс, исходный класс становится родителем, 
а новый – его потомком. Класс-потомок должен производить такие же операции, как и класс-родитель. 
Это называется наследственностью.

Необходимо, чтобы класс-потомок был способен обрабатывать те же запросы, что и родитель, и выдавать тот же результат. 
Или же результат может отличаться, но при этом относиться к тому же типу. На картинке это показано так: 
класс-родитель подаёт кофе (в любых видах), значит, для класса-потомка приемлемо подавать капучино 
(разновидность кофе), но неприемлемо подавать воду.

Если класс-потомок не удовлетворяет этим требованиям, значит, он слишком сильно отличается от родителя 
и нарушает принцип.

- Принцип служит для того, чтобы обеспечить постоянство: класс-родитель и класс-потомок могут использоваться 
одинаковым образом без нарушения работы программы.

**I — Interface Segregation** (Принцип разделения интерфейсов)

> Не следует ставить клиент в зависимость от методов, которые он не использует.

![icon][solid-i]

Когда классу приходится производить действия, не несущие никакой реальной пользы, 
это выливается в пустую трату ресурса, а в случае, если класс выполнять эти действия не способен, 
ведёт к возникновению багов.

Класс должен производить только те операции, которые необходимы для осуществления его функций. 
Все другие действия следует либо удалить совсем, либо переместить, если есть вероятность, 
что они понадобятся другому классу в будущем.

- Принцип служит для того, чтобы раздробить единый набор действий на ряд наборов поменьше – таким образом, 
каждый класс делает то, что от него действительно требуется, и ничего больше.

**D — Dependency Inversion** (Принцип инверсии зависимостей)

> Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. 
>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

![icon][solid-d]

Для начала объясню термины, которые здесь применяются, простыми словами.

Модули (или классы) верхнего уровня = классы, которые выполняют операцию при помощи инструмента
Модули (или классы) нижнего уровня = инструменты, которые нужны для выполнения операций
Абстракции – представляют интерфейс, соединяющий два класса
Детали = специфические характеристики работы инструмента

Согласно данному принципу, класс не должен соединяться с инструментом, который применяет для выполнения операции. 
Вместо этого он должен быть соединён с интерфейсом, который поможет установить связь между инструментом и классом.

Кроме того, принцип гласит, что ни интерфейс, ни класс, не обязаны вникать в специфику работы инструмента. 
Напротив, это инструмент должен подходить под требования интерфейса.

- Этот принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов нижнего уровня за 
счёт введения интерфейсов.

[к оглавлению](#Theory)


## Code Review Google Principces

1) Код не должен быть идеальным, но должен улучшать кодовую базу. Если код улучшает кодовую базу, 
то придираться к мелочам не стоит.
2) Разделение замечаний и придирок (свободных к исправлению "nit" от "nitpick" -  придирка)
3) Стандартные практики лучше "хитрых велосипедов"
4) Несогласие решается по схеме "Обсудили в коментах -> Обсудили лично -> Обсудили в команде -> Двигаемся дальше"
5) Чем выше скорость тем лучше
6) Делить большие МР на мелкие
7) Вежливость, чтобы не расстроить автора кода
8) То что временно - то на всегда

На что смотреть при Код ревью-
- Код хорошо спроектирован
- Функциональность хорошо сделана с точки зрения пользователей этого кода, кем бы они ни были.
- Внешний вид (если есть) должен быть хорошим
- Учтены все нюансы параллельного программирования (если есть).
- Код не переусложнен
- Разработчик не оверинженирит: не нужно писать код, который может понадобиться, а может не понадобиться
- У кода есть тесты
- Тесты хорошо спроектированы
- Наименования (для всего) выбраны хорошо
- Комментарии к коду понятны и необходимы. Они должны объяснять, почему так сделано, а не как это сделано.
- Добавлена документация.
- Код соответствует стайл гайдам.

[к оглавлению](#Theory)

## AUTH 

![icon][auth]
![icon][auth2]

[к оглавлению](#Theory)

## REST 

это акроним от *Representational State Transfer*. 
Это архитектурный стиль для распределенных систем, 
впервые введенный Роем Филдингом в 2000 году в его знаменитой диссертации.

Как и любой другой архитектурный стиль, REST имеет имеет свои ограничения, 
которые должны быть соблюдены, если интерфейс называется RESTful. Эти 6 принципов описаны ниже.

Руководящие принипы написания RESTful-интерфейсов.

- *Client-Server*. Отделяя пользовательский интерфейс от хранилища данных, 
мы улучшаем переносимость пользовательского интерфейса на другие платформы и 
улучшаем масштабируемость серверных компонент засчёт их упрощения.
- *Stateless* (без состояния). Каждый запрос от клиента к серверу должен содержать 
в себе всю необходимую информацию и не может полагаться на какое-либо состояние, 
хранящееся на стороне сервера. Таким образом, информация о текущей сессии должна целиком 
храниться у клиента.
- *Cacheable* (кэшируемость). Это ограничение требует, чтобы для данных в ответе на запрос 
явно было указано -- можно их кэшировать или нет. Если ответ поддерживает кэширование, 
то клиент имеет право повторно использовать данные в последующих эквивалентных запросов 
без обращения на сервер.
- *Uniform interface* (единообразие интерфейса). Если применить к систем инженерный принцип 
общности/единообразия, то архитектура всего приложения станет проще, 
а взаимодействие станет прозрачнее и понятнее. 
Для выполнения этого принципа необходимо придерживаться нескольких архитектурных ограничений. 
REST накладывает на интерфейс четыре ограничения: 
1) идентичность ресурсов; 
2) манипуляция над ресурсами через представление; 
3) исчерпывающие, понятные человеку сообщения; 
4) гипермедиа (hypermedia) как движок для состояния приложения (HATEOAS)-- ссылки на другие ресурсы внутри приложения.
- *Layered system* (многоуровневая система). Многоуровневость достигается засчёт 
ограничения поведения компонентов таким образом, что компоненты "не видят" другие компоненты, 
кроме расположенных на ближайших уровнях, с которыми они взаимодействуют.
- *Code on demand* (код по мере необходимости, необятельно). REST позволяет наращивать 
функциональность клиентского приложения по мере необходимости при помощи скачивания и 
исполнения кода в виде апплетов или скриптов. Это упрощает клиентские приложения, 
уменьшая количество заранее написанных возможностей.

POST -- create
GET -- read
PUT -- update/replace
DELETE -- delete
PATCH -- partial update/modify

[к оглавлению](#Theory)

## Richardson Maturity Model
![icon][rmm]
[к оглавлению](#Theory)

## HATEOAS
![icon][hateoas]
[к оглавлению](#Theory)

## Стратегии ветвения GIT
#### Три подхода

Вы можете использовать одну из этих популярных методик или же взять их как основу для создания своей.

#### GitHub Flow. 
Стратегией пользуются в команде сервиса GitHub. Главные требования звучат так:

- в коде в мастер-ветке не допускаются ошибки, 
и он должен быть готов к развертыванию в любой момент;
- чтобы начать разрабатывать новую функцию, 
необходимо создать feature-ветку в master-ветке и дать ей очевидное для всех имя. 
Когда работа будет готова, ее нужно смерджить в master-ветку через pull request;
- после мерджа изменений их нужно сразу же развернуть на сервере.
  
Этот подход обычно используют для продуктов с одной версией, 
которая обновляется не очень часто. Например, веб-сайтов. 
Из плюсов — разработчикам при таком подходе проще понимать и организовывать свою работу. Главный минус — если ваш проект достаточно сложный и обновляется часто, 
лучше использовать другую стратегию.

#### GitFlow. 
Сразу стоит сказать, что эта стратегия дискуссионная. 
О ней есть много как положительных, так и отрицательных отзывов.

Суть в следующем. Есть два типа постоянных веток: master-ветка, 
чтобы понимать, как выглядит последняя актуальная версия, и development-ветка, 
где ведется разработка. От нее идут три вида временных веток.

- Feature, для добавления новых возможностей. После завершения работы нужно создать pull request в development-ветку.
- Release, для работы над новыми версиями. Важно добавить в название номер версии, это поможет не запутаться и отследить изменения.
- Hotfix, для быстрого исправления багов.

Этот подход считается одним из оптимальных для проектов, 
где постоянно разрабатывается несколько версий для разных платформ.

#### Forking Workflow. 
Здесь подход такой: 
существует оригинальный репозиторий для мерджа всех изменений и его копия, 
в которой работает другой разработчик. Подход очень близок к идеологии open source, 
его цель — использовать все преимущества open-source-сообщества в рамках проекта. 
При этом большая часть рабочего процесса в части ветвления копирует GitFlow. 
Feature-ветки здесь будут мерджиться с локальными репозиториями разработчиков. 
Таким образом, разработка становится гибкой даже для очень больших команд с подрядчиками.

[к оглавлению](#Theory)

[Заглавная](README.md)