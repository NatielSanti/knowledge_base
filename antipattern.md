[Заглавная](README.md)

# Antipattern

+ [Analytical paralysis](antipattern.md#Analytical-paralysis)
+ [God object](antipattern.md#God-object)
+ [Singleton](antipattern.md#Singleton)
+ [Полтергейст](antipattern.md#Полтергейст)
+ [Hard code](antipattern.md#Hard-code)
+ [Boat anchor](antipattern.md#Boat-anchor)
+ [Golden hammer](antipattern.md#Golden-hammer)
+ [Premature optimization](antipattern.md#Premature-optimization)
+ [Spaghetti code](antipattern.md#Spaghetti-code)
+ [Magic numbers](antipattern.md#Magic-numbers)
+ [Copy and paste programming](antipattern.md#Copy-and-paste-programming)
+ [Yo-yo problem](antipattern.md#Yo-yo-problem)

[к оглавлению](#Antipattern)

## Analytical paralysis

**Аналитический паралич** — считается классическим организационным антипаттерном. 
Его суть заключается в чрезмерном анализировании ситуации при планировании, 
так что решение или действие не предпринимаются, по сути парализуя разработку. 
Зачастую это случается в тех случаях, когда цель состоит в достижении совершенства и полной завершенности 
периода анализа. Этот антипаттерн характеризуется хождением по кругу (такой себе замкнутый цикл), 
пересмотром и созданием детальных моделей, что в свою очередь мешает рабочему процессу.

Вот парочка небольших советов для борьбы аналитическим параличом:
- Нужно определить долгосрочную цель в качестве маяка для принятия решений, 
чтобы каждое ваше решение приближало к цели, а не заставляло топтаться на месте.
- Не концентрироваться на пустяках (зачем принимать решение по незначительному нюансу так, 
словно оно последнее в жизни?)
- Задайте крайний срок для принятия решения.
- Не старайтесь сделать задачу совершенно: лучше сделать очень хорошо.

[к оглавлению](#Antipattern)

## God object
**Божественный объект** — антипаттерн, который описывает излишнюю концентрацию слишком 
большого количества разношерстных функций, хранения большого количества разнообразных данных 
(объект, вокруг которого вращается приложение).

[к оглавлению](#Antipattern)

## Singleton

**Одиночка** — это самый простой паттерн, гарантирующий, что в однопоточном приложении будет единственный 
экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому объекту. 

- Глобальное состояние. Когда мы получаем доступ к экземпляру класса, мы не знаем текущее состояние этого класса, 
и кто и когда его менял, и это состояние может быть вовсе не таким, как ожидается. Иными словами, 
корректность работы с синглтоном зависит от порядка обращений к нему, что вызывает зависимость 
подсистем друг от друга и, как следствие, серьезно повышает сложность разработки.

- Синглтон нарушает один из принципов **SOLID** — *Single Responsibility Principle* — класс синглтона, 
помимо выполнения своих непосредственных обязанностей, занимается еще и контролированием количества 
своих экземпляров.

- Зависимость обычного класса от синглтона не видна в интерфейсе класса. Так как обычно экземпляр 
синглтона не передается в параметрах метода, а получается напрямую, через `getInstance()`, 
для выявления зависимости класса от синглтона надо залезть в реализацию каждого метода — 
просто просмотреть публичный контракт объекта недостаточно.

[к оглавлению](#Antipattern)

## Полтергейст 
— это антипаттерн класса, не несущего пользы, 
который используется для вызова методов другого класса или просто добавляет ненужный слой абстракции. 
Антипаттерн проявляется в виде короткоживущих объектов, лишенных состояния. 
Эти объекты часто используются для инициализации другие, более устойчивых объектов.

[к оглавлению](#Antipattern)

## Hard code
Вот мы и добрались до этого страшного слова — хардкод. 
Суть данного антипаттерна в том, что код сильно привязан к конкретной аппаратной конфигурации 
и/или системному окружению, что сильно усложняет перенос его на другие конфигурации. 
Данный антипаттерн тесно связан с магическими числами (они часто переплетаются).

[к оглавлению](#Antipattern)

## Boat anchor
Лодочный якорь в контексте антипаттернов означает хранение неиспользуемых частей системы, 
которые остались после какой-то оптимизации или рефакторинга. 
Также некоторые части кода могли быть оставлены «на будущее», вдруг придётся ещё их использовать. 
По сути это делает из кода мусорное ведро.

[к оглавлению](#Antipattern)

## Golden hammer
Золотой молоток — это антипаттерн, описывающий уверенность в полной универсальности какого-либо 
решения и применение этого решения повсеместно.

Примеры:
- Разработчик, который однажды сталкивается с какой-то проблемой и находит паттерн для идеального решения, 
пытается всунуть этот шаблон везде, внедряя в текущие и все будущие проекты, 
вместо того, чтобы искать подходящие решения под конкретные случаи.

- Группа разработчиков однажды создали свой аналог кеша под конкретную ситуацию (ибо ни один другой не подходил),
и в итоге уже на следующем проекте, в котором нет специфической логики относительно кеша, 
они используют его же вместо того, чтобы работать с готовыми библиотеками (как например, Ehcache). 
Из-за этого вылазит куча багов и несостыковок, и как итог — куча времени и нервов впустую.

С данным антипаттерном могу столкнуться все. Если ты новичок, возможно, 
тебе не хватает знаний в шаблонах проектирования и, как следствие, 
ты пытаешься решить все задачи единственным известным способом, который освоил. 
Если же мы говорим о профессионалах, у них присутствует профессиональная деформация. 
У тебя свои предпочтения в шаблонах проектирования, и вместо использования нужного используешь любимый, 
полагаясь на логику, что хорошая работа в прошлом гарантирует тот же результат и в будущем.

Итог ошибки может быть весьма печальным: от плохой, нестабильной, 
трудной в поддержке реализации до полного провала проекта. Ведь нет одной таблетки от всех болезней, 
как и нет одного шаблона на все случаи жизни.

[к оглавлению](#Antipattern)

## Premature optimization
Преждевременная оптимизация — это антипаттерн, название которого говорит за себя
Как пример — преждевременное добавление индексов в базу данных. Чем это плохо? 
А тем, индексы хранятся в виде бинарного дерева, и соответственно,  
при каждом добавлении и удалении нового значения дерево будет пересчитываться заново, 
а это всё ресурсы и время. Поэтому, индексы нужно добавлять лишь при острой необходимости 
(при большом количестве данных и недостаточной скорости поиска по ним) и на самые значимые поля 
(по которым чаще всего ищут).

[к оглавлению](#Antipattern)

## Spaghetti code
Спагетти-код — это антипаттерн, описывающий часть кода, которая является плохо структурированной, 
запутанной и трудной для понимания, содержащей много всяких переходов, каких как: 
оборачивание исключений, условий, циклов.

[к оглавлению](#Antipattern)

## Magic numbers
Магическое числа — это антипаттерн, который затрагивает разнородные константы в программе без пояснения их цели,
 смысла. То есть, как правило нет адекватного имени или на крайний случай, комментария, поясняющего, что и зачем.
  Также как и спагетти код, является одним из наиболее распространённых антипаттернов.

Человек, который не является автором данного кода, с трудом может или вовсе не может объяснить, 
что это и как оно работает (да и сам автор со временем не сможет). 
В итоге при изменении этого числа или его удалении код магически перестает работать вовсе.

[к оглавлению](#Antipattern)

## Copy and paste programming
Программирование путём копирования и вставки — это антипаттерн, подразумевающий собой бездумное копирование 
чужого кода (copy and paste), вследствие чего могут возникать побочные эффекты, которые мы не досмотрели.

[к оглавлению](#Antipattern)

## Yo-yo problem
Проблема йо йо — антипаттерн, при котором структура приложения, чрезмерно размыта в связи с избыточной 
фрагментацией (например, избыточно разбита цепочка наследования).

“Проблема Йо-Йо” возникает, когда необходимо разобраться в программе, иерархия наследования и вложенность 
вызовов методов которой очень длинна и сложна. Программисту вследствие этого необходимо лавировать между 
множеством различных классов и методов, чтобы контролировать поведение программы. 
Термин происходит от названия игрушки йо-йо.

[к оглавлению](#Antipattern)

[Заглавная](README.md)