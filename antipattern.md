[Заглавная](README.md)

# Antipattern

+ [Analytical paralysis](antipattern.md#Analytical-paralysis)
+ [God object](antipattern.md#God-object)
+ [Singleton](antipattern.md#Singleton)
+ [Полтергейст](antipattern.md#Полтергейст)
+ [Hard code](antipattern.md#Hard-code)
+ [Boat anchor](antipattern.md#Boat-anchor)
+ [Golden hammer](antipattern.md#Golden-hammer)
+ [Premature optimization](antipattern.md#Premature-optimization)
+ [Spaghetti code](antipattern.md#Spaghetti-code)
+ [Magic numbers](antipattern.md#Magic-numbers)
+ [Copy and paste programming](antipattern.md#Copy-and-paste-programming)
+ [Yo-yo problem](antipattern.md#Yo-yo-problem)
+ [Other](design-patterns.md#Другие)

[к оглавлению](#Antipattern)

## Analytical paralysis

**Аналитический паралич** — считается классическим организационным антипаттерном. 
Его суть заключается в чрезмерном анализировании ситуации при планировании, 
так что решение или действие не предпринимаются, по сути парализуя разработку. 
Зачастую это случается в тех случаях, когда цель состоит в достижении совершенства и полной завершенности 
периода анализа. Этот антипаттерн характеризуется хождением по кругу (такой себе замкнутый цикл), 
пересмотром и созданием детальных моделей, что в свою очередь мешает рабочему процессу.

Вот парочка небольших советов для борьбы аналитическим параличом:
- Нужно определить долгосрочную цель в качестве маяка для принятия решений, 
чтобы каждое ваше решение приближало к цели, а не заставляло топтаться на месте.
- Не концентрироваться на пустяках (зачем принимать решение по незначительному нюансу так, 
словно оно последнее в жизни?)
- Задайте крайний срок для принятия решения.
- Не старайтесь сделать задачу совершенно: лучше сделать очень хорошо.

[к оглавлению](#Antipattern)

## God object
**Божественный объект** — антипаттерн, который описывает излишнюю концентрацию слишком 
большого количества разношерстных функций, хранения большого количества разнообразных данных 
(объект, вокруг которого вращается приложение).

[к оглавлению](#Antipattern)

## Singleton

**Одиночка** — это самый простой паттерн, гарантирующий, что в однопоточном приложении будет единственный 
экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому объекту. 

- Глобальное состояние. Когда мы получаем доступ к экземпляру класса, мы не знаем текущее состояние этого класса, 
и кто и когда его менял, и это состояние может быть вовсе не таким, как ожидается. Иными словами, 
корректность работы с синглтоном зависит от порядка обращений к нему, что вызывает зависимость 
подсистем друг от друга и, как следствие, серьезно повышает сложность разработки.

- Синглтон нарушает один из принципов **SOLID** — *Single Responsibility Principle* — класс синглтона, 
помимо выполнения своих непосредственных обязанностей, занимается еще и контролированием количества 
своих экземпляров.

- Зависимость обычного класса от синглтона не видна в интерфейсе класса. Так как обычно экземпляр 
синглтона не передается в параметрах метода, а получается напрямую, через `getInstance()`, 
для выявления зависимости класса от синглтона надо залезть в реализацию каждого метода — 
просто просмотреть публичный контракт объекта недостаточно.

- Сложно тестировать, потому что нельзя замокать.

[к оглавлению](#Antipattern)

## Полтергейст 
— это антипаттерн класса, не несущего пользы, 
который используется для вызова методов другого класса или просто добавляет ненужный слой абстракции. 
Антипаттерн проявляется в виде короткоживущих объектов, лишенных состояния. 
Эти объекты часто используются для инициализации другие, более устойчивых объектов.

[к оглавлению](#Antipattern)

## Hard code
Вот мы и добрались до этого страшного слова — хардкод. 
Суть данного антипаттерна в том, что код сильно привязан к конкретной аппаратной конфигурации 
и/или системному окружению, что сильно усложняет перенос его на другие конфигурации. 
Данный антипаттерн тесно связан с магическими числами (они часто переплетаются).

[к оглавлению](#Antipattern)

## Boat anchor
Лодочный якорь в контексте антипаттернов означает хранение неиспользуемых частей системы, 
которые остались после какой-то оптимизации или рефакторинга. 
Также некоторые части кода могли быть оставлены «на будущее», вдруг придётся ещё их использовать. 
По сути это делает из кода мусорное ведро.

[к оглавлению](#Antipattern)

## Golden hammer
Золотой молоток — это антипаттерн, описывающий уверенность в полной универсальности какого-либо 
решения и применение этого решения повсеместно.

Примеры:
- Разработчик, который однажды сталкивается с какой-то проблемой и находит паттерн для идеального решения, 
пытается всунуть этот шаблон везде, внедряя в текущие и все будущие проекты, 
вместо того, чтобы искать подходящие решения под конкретные случаи.

- Группа разработчиков однажды создали свой аналог кеша под конкретную ситуацию (ибо ни один другой не подходил),
и в итоге уже на следующем проекте, в котором нет специфической логики относительно кеша, 
они используют его же вместо того, чтобы работать с готовыми библиотеками (как например, Ehcache). 
Из-за этого вылазит куча багов и несостыковок, и как итог — куча времени и нервов впустую.

С данным антипаттерном могу столкнуться все. Если ты новичок, возможно, 
тебе не хватает знаний в шаблонах проектирования и, как следствие, 
ты пытаешься решить все задачи единственным известным способом, который освоил. 
Если же мы говорим о профессионалах, у них присутствует профессиональная деформация. 
У тебя свои предпочтения в шаблонах проектирования, и вместо использования нужного используешь любимый, 
полагаясь на логику, что хорошая работа в прошлом гарантирует тот же результат и в будущем.

Итог ошибки может быть весьма печальным: от плохой, нестабильной, 
трудной в поддержке реализации до полного провала проекта. Ведь нет одной таблетки от всех болезней, 
как и нет одного шаблона на все случаи жизни.

[к оглавлению](#Antipattern)

## Premature optimization
Преждевременная оптимизация — это антипаттерн, название которого говорит за себя
Как пример — преждевременное добавление индексов в базу данных. Чем это плохо? 
А тем, индексы хранятся в виде бинарного дерева, и соответственно,  
при каждом добавлении и удалении нового значения дерево будет пересчитываться заново, 
а это всё ресурсы и время. Поэтому, индексы нужно добавлять лишь при острой необходимости 
(при большом количестве данных и недостаточной скорости поиска по ним) и на самые значимые поля 
(по которым чаще всего ищут).

[к оглавлению](#Antipattern)

## Spaghetti code
Спагетти-код — это антипаттерн, описывающий часть кода, которая является плохо структурированной, 
запутанной и трудной для понимания, содержащей много всяких переходов, каких как: 
оборачивание исключений, условий, циклов.

[к оглавлению](#Antipattern)

## Magic numbers
Магическое числа — это антипаттерн, который затрагивает разнородные константы в программе без пояснения их цели,
 смысла. То есть, как правило нет адекватного имени или на крайний случай, комментария, поясняющего, что и зачем.
  Также как и спагетти код, является одним из наиболее распространённых антипаттернов.

Человек, который не является автором данного кода, с трудом может или вовсе не может объяснить, 
что это и как оно работает (да и сам автор со временем не сможет). 
В итоге при изменении этого числа или его удалении код магически перестает работать вовсе.

[к оглавлению](#Antipattern)

## Copy and paste programming
Программирование путём копирования и вставки — это антипаттерн, подразумевающий собой бездумное копирование 
чужого кода (copy and paste), вследствие чего могут возникать побочные эффекты, которые мы не досмотрели.

[к оглавлению](#Antipattern)

## Yo-yo problem
Проблема йо йо — антипаттерн, при котором структура приложения, чрезмерно размыта в связи с избыточной 
фрагментацией (например, избыточно разбита цепочка наследования).

“Проблема Йо-Йо” возникает, когда необходимо разобраться в программе, иерархия наследования и вложенность 
вызовов методов которой очень длинна и сложна. Программисту вследствие этого необходимо лавировать между 
множеством различных классов и методов, чтобы контролировать поведение программы. 
Термин происходит от названия игрушки йо-йо.

[к оглавлению](#Antipattern)

## Другие

**Антипаттерн (anti-pattern)** — это распространённый подход к решению класса часто встречающихся проблем, 
являющийся неэффективным, рискованным или непродуктивным.

**Poltergeists (полтергейсты)** - это классы с ограниченной ответственностью и ролью в системе, 
чьё единственное предназначение — передавать информацию в другие классы. Их эффективный жизненный цикл непродолжителен. 
Полтергейсты нарушают стройность архитектуры программного обеспечения, создавая избыточные (лишние) абстракции, 
они чрезмерно запутанны, сложны для понимания и трудны в сопровождении. 
Обычно такие классы задумываются как классы-контроллеры, которые существуют только для вызова методов других классов, 
зачастую в предопределенной последовательности.

#### Признаки появления и последствия антипаттерна

-Избыточные межклассовые связи.
-Временные ассоциации.
-Классы без состояния (содержащие только методы и константы).
-Временные объекты и классы (с непродолжительным временем жизни).
-Классы с единственным методом, который предназначен только для создания или вызова других классов посредством 
временной ассоциации.
-Классы с именами методов в стиле «управления», такие как startProcess.

#### Типичные причины

-Отсутствие объектно-ориентированной архитектуры (архитектор не понимает объектно-ориентированной парадигмы).
-Неправильный выбор пути решения задачи.
-Предположения об архитектуре приложения на этапе анализа требований (до объектно-ориентированного анализа) 
могут также вести к проблемам на подобии этого антипаттерна.

1) **Внесенная сложность (Introduced complexity):** Необязательная сложность дизайна. 
Вместо одного простого класса выстраивается целая иерархия интерфейсов и классов. Типичный пример «Интерфейс - 
Абстрактный класс - Единственный класс реализующий интерфейс на основе абстрактного».

2) **Инверсия абстракции (Abstraction inversion):** Сокрытие части функциональности от внешнего использования, 
в надежде на то, что никто не будет его использовать.

3) **Неопределённая точка зрения (Ambiguous viewpoint):** Представление модели без спецификации её точки рассмотрения.

4) **Большой комок грязи (Big ball of mud):** Система с нераспознаваемой структурой.

5) **Божественный объект (God object):** Концентрация слишком большого количества функций в одной части системы 
(классе).

6) **Затычка на ввод данных (Input kludge):** Забывчивость в спецификации и выполнении поддержки возможного 
неверного ввода.

7) **Раздувание интерфейса (Interface bloat):** Разработка интерфейса очень мощным и очень сложным для реализации.

8) **Волшебная кнопка (Magic pushbutton):** Выполнение результатов действий пользователя в виде неподходящего 
(недостаточно абстрактного) интерфейса. Например, написание прикладной логики в обработчиках нажатий на кнопку.

9) **Перестыковка (Re-Coupling):** Процесс внедрения ненужной зависимости.

10) **Дымоход (Stovepipe System):** Редко поддерживаемая сборка плохо связанных компонентов.

11) **Состояние гонки (Race hazard):** непредвидение возможности наступления событий в порядке, отличном от ожидаемого.

12) **Членовредительство (Mutilation):** Излишнее «затачивание» объекта под определенную очень узкую 
задачу таким образом, что он не способен будет работать с никакими иными, пусть и очень схожими задачами.

13) **Сохранение или смерть (Save or die):** Сохранение изменений лишь при завершении приложения.

[к оглавлению](#Antipattern)

[Заглавная](README.md)